-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Attoparsec and Pipes integration.
--   
--   Utilities to run Attoparsec parsers on Pipes input streams.
--   
--   See the <tt>changelog.md</tt> file in the source distribution to learn
--   about any important changes between version.
@package pipes-attoparsec
@version 0.5.1.2


-- | <tt>pipes</tt> utilities for incrementally running
--   <tt>attoparsec</tt>-based parsers.
--   
--   This module assumes familiarity with <tt>pipes-parse</tt>, you can
--   learn about it in <a>Pipes.Parse.Tutorial</a>.
module Pipes.Attoparsec

-- | Convert an <tt>attoparsec</tt> <a>Parser</a> to a <tt>pipes-parse</tt>
--   <a>Parser</a>.
--   
--   This <a>Parser</a> is compatible with the tools from
--   <a>Pipes.Parse</a>.
--   
--   It returns <a>Nothing</a> if the underlying <a>Producer</a> is
--   exhausted, otherwise it attempts to run the given attoparsec
--   <a>Parser</a> on the underlying <a>Producer</a>, possibly failing with
--   <a>ParsingError</a>.
parse :: (Monad m, ParserInput a) => Parser a b -> Parser a m (Maybe (Either ParsingError b))

-- | Convert a producer of <a>ParserInput</a> to a producer of parsed
--   values.
--   
--   This producer returns <a>Right</a> when end-of-input is reached
--   sucessfully, otherwise it returns a <a>ParsingError</a> and the
--   leftovers including the malformed input that couldn't be parsed. You
--   can use <a>errorP</a> to promote the <a>Either</a> return value to an
--   <a>ErrorT</a> monad transformer.
parsed :: (Monad m, ParserInput a) => Parser a b -> Producer a m r -> Producer b m (Either (ParsingError, Producer a m r) r)

-- | Like <a>parse</a>, but also returns the length of input consumed to
--   parse the value.
parseL :: (Monad m, ParserInput a) => Parser a b -> Parser a m (Maybe (Either ParsingError (Int, b)))

-- | Like <a>parsed</a>, except this tags each parsed value with the length
--   of input consumed to parse the value.
parsedL :: (Monad m, ParserInput a) => Parser a b -> Producer a m r -> Producer (Int, b) m (Either (ParsingError, Producer a m r) r)

-- | Like <a>isEndOfInput</a>, except that it also consumes and discards
--   leading empty chunks.
isEndOfParserInput :: (Monad m, ParserInput a) => Parser a m Bool

-- | A class for valid <tt>attoparsec</tt> input types
class (Eq a, Monoid a) => ParserInput a

-- | A parsing error report, as provided by Attoparsec's <a>Fail</a>.
data ParsingError
ParsingError :: [String] -> String -> ParsingError

-- | Contexts where the parsing error occurred.
[peContexts] :: ParsingError -> [String]

-- | Parsing error description message.
[peMessage] :: ParsingError -> String
instance Data.Data.Data Pipes.Attoparsec.ParsingError
instance GHC.Classes.Eq Pipes.Attoparsec.ParsingError
instance GHC.Read.Read Pipes.Attoparsec.ParsingError
instance GHC.Show.Show Pipes.Attoparsec.ParsingError
instance Pipes.Attoparsec.ParserInput Data.ByteString.Internal.ByteString
instance Pipes.Attoparsec.ParserInput Data.Text.Internal.Text
instance GHC.Exception.Exception Pipes.Attoparsec.ParsingError
instance Control.Monad.Trans.Error.Error Pipes.Attoparsec.ParsingError
instance Control.Monad.Trans.Error.Error (Pipes.Attoparsec.ParsingError, Pipes.Core.Producer a m r)
