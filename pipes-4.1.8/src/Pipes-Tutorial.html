<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Pipes/Tutorial.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS_GHC -fno-warn-unused-imports #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-comment'>{-| Conventional Haskell stream programming forces you to choose only two of the
<a name="line-4"></a>    following three features:
<a name="line-5"></a>
<a name="line-6"></a>    * Effects
<a name="line-7"></a>
<a name="line-8"></a>    * Streaming
<a name="line-9"></a>
<a name="line-10"></a>    * Composability
<a name="line-11"></a>
<a name="line-12"></a>    If you sacrifice /Effects/ you get Haskell's pure and lazy lists, which you
<a name="line-13"></a>    can transform using composable functions in constant space, but without
<a name="line-14"></a>    interleaving effects.
<a name="line-15"></a>
<a name="line-16"></a>    If you sacrifice /Streaming/ you get 'mapM', 'forM' and
<a name="line-17"></a>    \"ListT done wrong\", which are composable and effectful, but do not return
<a name="line-18"></a>    a single result until the whole list has first been processed and loaded
<a name="line-19"></a>    into memory.
<a name="line-20"></a>
<a name="line-21"></a>    If you sacrifice /Composability/ you write a tightly coupled read,
<a name="line-22"></a>    transform, and write loop in 'IO', which is streaming and effectful, but is
<a name="line-23"></a>    not modular or separable.
<a name="line-24"></a>
<a name="line-25"></a>    @pipes@ gives you all three features: effectful, streaming, and composable
<a name="line-26"></a>    programming.  @pipes@ also provides a wide variety of stream programming
<a name="line-27"></a>    abstractions which are all subsets of a single unified machinery:
<a name="line-28"></a>
<a name="line-29"></a>    * effectful 'Producer's (like generators),
<a name="line-30"></a>
<a name="line-31"></a>    * effectful 'Consumer's (like iteratees),
<a name="line-32"></a>
<a name="line-33"></a>    * effectful 'Pipe's (like Unix pipes), and:
<a name="line-34"></a>
<a name="line-35"></a>    * 'ListT' done right.
<a name="line-36"></a>
<a name="line-37"></a>    All of these are connectable and you can combine them together in clever and
<a name="line-38"></a>    unexpected ways because they all share the same underlying type.
<a name="line-39"></a>
<a name="line-40"></a>    @pipes@ requires a basic understanding of monad transformers, which you can
<a name="line-41"></a>    learn about by reading either:
<a name="line-42"></a>
<a name="line-43"></a>    * the paper \"Monad Transformers - Step by Step\",
<a name="line-44"></a>
<a name="line-45"></a>    * chapter 18 of \"Real World Haskell\" on monad transformers, or:
<a name="line-46"></a>
<a name="line-47"></a>    * the documentation of the @transformers@ library.
<a name="line-48"></a>
<a name="line-49"></a>    If you want a Quick Start guide to @pipes@, read the documentation in
<a name="line-50"></a>    "Pipes.Prelude" from top to bottom.
<a name="line-51"></a>
<a name="line-52"></a>    This tutorial is more extensive and explains the @pipes@ API in greater
<a name="line-53"></a>    detail and illustrates several idioms.
<a name="line-54"></a>-}</span>
<a name="line-55"></a>
<a name="line-56"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Tutorial</span> <span class='hs-layout'>(</span>
<a name="line-57"></a>    <span class='hs-comment'>-- * Introduction</span>
<a name="line-58"></a>    <span class='hs-comment'>-- $introduction</span>
<a name="line-59"></a>
<a name="line-60"></a>    <span class='hs-comment'>-- * Producers</span>
<a name="line-61"></a>    <span class='hs-comment'>-- $producers</span>
<a name="line-62"></a>
<a name="line-63"></a>    <span class='hs-comment'>-- * Composability</span>
<a name="line-64"></a>    <span class='hs-comment'>-- $composability</span>
<a name="line-65"></a>
<a name="line-66"></a>    <span class='hs-comment'>-- * Consumers</span>
<a name="line-67"></a>    <span class='hs-comment'>-- $consumers</span>
<a name="line-68"></a>
<a name="line-69"></a>    <span class='hs-comment'>-- * Pipes</span>
<a name="line-70"></a>    <span class='hs-comment'>-- $pipes</span>
<a name="line-71"></a>
<a name="line-72"></a>    <span class='hs-comment'>-- * ListT</span>
<a name="line-73"></a>    <span class='hs-comment'>-- $listT</span>
<a name="line-74"></a>
<a name="line-75"></a>    <span class='hs-comment'>-- * Tricks</span>
<a name="line-76"></a>    <span class='hs-comment'>-- $tricks</span>
<a name="line-77"></a>
<a name="line-78"></a>    <span class='hs-comment'>-- * Conclusion</span>
<a name="line-79"></a>    <span class='hs-comment'>-- $conclusion</span>
<a name="line-80"></a>
<a name="line-81"></a>    <span class='hs-comment'>-- * Appendix: Types</span>
<a name="line-82"></a>    <span class='hs-comment'>-- $types</span>
<a name="line-83"></a>
<a name="line-84"></a>    <span class='hs-comment'>-- * Appendix: Time Complexity</span>
<a name="line-85"></a>    <span class='hs-comment'>-- $timecomplexity</span>
<a name="line-86"></a>
<a name="line-87"></a>    <span class='hs-comment'>-- * Copyright</span>
<a name="line-88"></a>    <span class='hs-comment'>-- $copyright</span>
<a name="line-89"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-90"></a>
<a name="line-91"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Category</span>
<a name="line-92"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-93"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>Error</span>
<a name="line-94"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>Writer</span><span class='hs-varop'>.</span><span class='hs-conid'>Strict</span>
<a name="line-95"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span>
<a name="line-96"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Lift</span>
<a name="line-97"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Prelude</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>P</span>
<a name="line-98"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-99"></a>
<a name="line-100"></a><span class='hs-comment'>{- $introduction
<a name="line-101"></a>    The @pipes@ library decouples stream processing stages from each other so
<a name="line-102"></a>    that you can mix and match diverse stages to produce useful streaming
<a name="line-103"></a>    programs.  If you are a library writer, @pipes@ lets you package up
<a name="line-104"></a>    streaming components into a reusable interface.  If you are an application
<a name="line-105"></a>    writer, @pipes@ lets you connect pre-made streaming components with minimal
<a name="line-106"></a>    effort to produce a highly-efficient program that streams data in constant
<a name="line-107"></a>    memory.
<a name="line-108"></a>
<a name="line-109"></a>    To enforce loose coupling, components can only communicate using two
<a name="line-110"></a>    commands:
<a name="line-111"></a>
<a name="line-112"></a>    * 'yield': Send output data
<a name="line-113"></a>
<a name="line-114"></a>    * 'await': Receive input data
<a name="line-115"></a>
<a name="line-116"></a>    @pipes@ has four types of components built around these two commands:
<a name="line-117"></a>
<a name="line-118"></a>    * 'Producer's can only 'yield' values and they model streaming sources
<a name="line-119"></a>
<a name="line-120"></a>    * 'Consumer's can only 'await' values and they model streaming sinks
<a name="line-121"></a>
<a name="line-122"></a>    * 'Pipe's can both 'yield' and 'await' values and they model stream
<a name="line-123"></a>      transformations
<a name="line-124"></a>
<a name="line-125"></a>    * 'Effect's can neither 'yield' nor 'await' and they model non-streaming
<a name="line-126"></a>      components
<a name="line-127"></a>
<a name="line-128"></a>    You can connect these components together in four separate ways which
<a name="line-129"></a>    parallel the four above types:
<a name="line-130"></a>
<a name="line-131"></a>    * 'for' handles 'yield's
<a name="line-132"></a>
<a name="line-133"></a>    * ('&gt;~') handles 'await's
<a name="line-134"></a>
<a name="line-135"></a>    * ('&gt;-&gt;') handles both 'yield's and 'await's
<a name="line-136"></a>
<a name="line-137"></a>    * ('&gt;&gt;=') handles return values
<a name="line-138"></a>
<a name="line-139"></a>    As you connect components their types will change to reflect inputs and
<a name="line-140"></a>    outputs that you've fused away.  You know that you're done connecting things
<a name="line-141"></a>    when you get an 'Effect', meaning that you have handled all inputs and
<a name="line-142"></a>    outputs.  You run this final 'Effect' to begin streaming.
<a name="line-143"></a>-}</span>
<a name="line-144"></a>
<a name="line-145"></a><span class='hs-comment'>{- $producers
<a name="line-146"></a>    'Producer's are effectful streams of input.  Specifically, a 'Producer' is a
<a name="line-147"></a>    monad transformer that extends any base monad with a new 'yield' command.
<a name="line-148"></a>    This 'yield' command lets you send output downstream to an anonymous
<a name="line-149"></a>    handler, decoupling how you generate values from how you consume them.
<a name="line-150"></a>
<a name="line-151"></a>    The following @stdinLn@ 'Producer' shows how to incrementally read in
<a name="line-152"></a>    'String's from standard input and 'yield' them downstream, terminating
<a name="line-153"></a>    gracefully when reaching the end of the input:
<a name="line-154"></a>
<a name="line-155"></a>&gt; -- echo.hs
<a name="line-156"></a>&gt;
<a name="line-157"></a>&gt; import Control.Monad (unless)
<a name="line-158"></a>&gt; import Pipes
<a name="line-159"></a>&gt; import System.IO (isEOF)
<a name="line-160"></a>&gt;
<a name="line-161"></a>&gt; --         +--------+-- A 'Producer' that yields 'String's
<a name="line-162"></a>&gt; --         |        |
<a name="line-163"></a>&gt; --         |        |      +-- Every monad transformer has a base monad.
<a name="line-164"></a>&gt; --         |        |      |   This time the base monad is 'IO'.
<a name="line-165"></a>&gt; --         |        |      |  
<a name="line-166"></a>&gt; --         |        |      |  +-- Every monadic action has a return value.
<a name="line-167"></a>&gt; --         |        |      |  |   This action returns '()' when finished
<a name="line-168"></a>&gt; --         v        v      v  v
<a name="line-169"></a>&gt; stdinLn :: Producer String IO ()
<a name="line-170"></a>&gt; stdinLn = do
<a name="line-171"></a>&gt;     eof &lt;- lift isEOF        -- 'lift' an 'IO' action from the base monad
<a name="line-172"></a>&gt;     unless eof $ do
<a name="line-173"></a>&gt;         str &lt;- lift getLine
<a name="line-174"></a>&gt;         yield str            -- 'yield' the 'String'
<a name="line-175"></a>&gt;         stdinLn              -- Loop
<a name="line-176"></a>
<a name="line-177"></a>    'yield' emits a value, suspending the current 'Producer' until the value is
<a name="line-178"></a>    consumed.  If nobody consumes the value (which is possible) then 'yield'
<a name="line-179"></a>    never returns.  You can think of 'yield' as having the following type:
<a name="line-180"></a>
<a name="line-181"></a>@
<a name="line-182"></a> 'yield' :: 'Monad' m =&gt; a -&gt; 'Producer' a m ()
<a name="line-183"></a>@
<a name="line-184"></a>
<a name="line-185"></a>    The true type of 'yield' is actually more general and powerful.  Throughout
<a name="line-186"></a>    the tutorial I will present type signatures like this that are simplified at
<a name="line-187"></a>    first and then later reveal more general versions.  So read the above type
<a name="line-188"></a>    signature as simply saying: \"You can use 'yield' within a 'Producer', but
<a name="line-189"></a>    you may be able to use 'yield' in other contexts, too.\"
<a name="line-190"></a>
<a name="line-191"></a>    Click the link to 'yield' to navigate to its documentation.  There you will
<a name="line-192"></a>    see that 'yield' actually uses the 'Producer'' (with an apostrophe) type
<a name="line-193"></a>    synonym which hides a lot of polymorphism behind a simple veneer.  The
<a name="line-194"></a>    documentation for 'yield' says that you can also use 'yield' within a
<a name="line-195"></a>    'Pipe', too, because of this polymorphism:
<a name="line-196"></a>
<a name="line-197"></a>@
<a name="line-198"></a> 'yield' :: 'Monad' m =&gt; a -&gt; 'Pipe' x a m ()
<a name="line-199"></a>@
<a name="line-200"></a>
<a name="line-201"></a>    Use simpler types like these to guide you until you understand the fully
<a name="line-202"></a>    general type.
<a name="line-203"></a>
<a name="line-204"></a>    'for' loops are the simplest way to consume a 'Producer' like @stdinLn@.
<a name="line-205"></a>    'for' has the following type:
<a name="line-206"></a>
<a name="line-207"></a>@
<a name="line-208"></a> \-\-                +-- Producer      +-- The body of the   +-- Result
<a name="line-209"></a> \-\-                |   to loop       |   loop              |
<a name="line-210"></a> \-\-                v   over          v                     v
<a name="line-211"></a> \-\-                --------------    ------------------    ----------
<a name="line-212"></a> 'for' :: 'Monad' m =&gt; 'Producer' a m r -&gt; (a -&gt; 'Effect' m ()) -&gt; 'Effect' m r
<a name="line-213"></a>@
<a name="line-214"></a>
<a name="line-215"></a>    @(for producer body)@ loops over @(producer)@, substituting each 'yield' in
<a name="line-216"></a>    @(producer)@ with @(body)@.
<a name="line-217"></a>
<a name="line-218"></a>    You can also deduce that behavior purely from the type signature:
<a name="line-219"></a>
<a name="line-220"></a>    * The body of the loop takes exactly one argument of type @(a)@, which is
<a name="line-221"></a>      the same as the output type of the 'Producer'.  Therefore, the body of the
<a name="line-222"></a>      loop must get its input from that 'Producer' and nowhere else.
<a name="line-223"></a>
<a name="line-224"></a>    * The return value of the input 'Producer' matches the return value of the
<a name="line-225"></a>      result, therefore 'for' must loop over the entire 'Producer' and not skip
<a name="line-226"></a>      anything.
<a name="line-227"></a>
<a name="line-228"></a>    The above type signature is not the true type of 'for', which is actually
<a name="line-229"></a>    more general.  Think of the above type signature as saying: \"If the first
<a name="line-230"></a>    argument of 'for' is a 'Producer' and the second argument returns an
<a name="line-231"></a>    'Effect', then the final result must be an 'Effect'.\"
<a name="line-232"></a>
<a name="line-233"></a>    Click the link to 'for' to navigate to its documentation.  There you will
<a name="line-234"></a>    see the fully general type and underneath you will see equivalent simpler
<a name="line-235"></a>    types.  One of these says that if the body of the loop is a 'Producer', then
<a name="line-236"></a>    the result is a 'Producer', too:
<a name="line-237"></a>
<a name="line-238"></a>@
<a name="line-239"></a> 'for' :: 'Monad' m =&gt; 'Producer' a m r -&gt; (a -&gt; 'Producer' b m ()) -&gt; 'Producer' b m r
<a name="line-240"></a>@
<a name="line-241"></a>
<a name="line-242"></a>    The first type signature I showed for 'for' was a special case of this
<a name="line-243"></a>    slightly more general signature because a 'Producer' that never 'yield's is
<a name="line-244"></a>    also an 'Effect':
<a name="line-245"></a>
<a name="line-246"></a>@
<a name="line-247"></a> data 'X'  -- The uninhabited type
<a name="line-248"></a>
<a name="line-249"></a>\ type 'Effect' m r = 'Producer' 'X' m r
<a name="line-250"></a>@
<a name="line-251"></a>
<a name="line-252"></a>    This is why 'for' permits two different type signatures.  The first type
<a name="line-253"></a>    signature is just a special case of the second one:
<a name="line-254"></a>
<a name="line-255"></a>@
<a name="line-256"></a> 'for' :: 'Monad' m =&gt; 'Producer' a m r -&gt; (a -&gt; 'Producer' b m ()) -&gt; 'Producer' b m r
<a name="line-257"></a>
<a name="line-258"></a>\ -- Specialize \'b\' to \'X\'
<a name="line-259"></a> 'for' :: 'Monad' m =&gt; 'Producer' a m r -&gt; (a -&gt; 'Producer' 'X' m ()) -&gt; 'Producer' 'X' m r
<a name="line-260"></a>
<a name="line-261"></a>\ -- Producer X = Effect
<a name="line-262"></a> 'for' :: 'Monad' m =&gt; 'Producer' a m r -&gt; (a -&gt; 'Effect'     m ()) -&gt; 'Effect'     m r
<a name="line-263"></a>@
<a name="line-264"></a>
<a name="line-265"></a>    This is the same trick that all @pipes@ functions use to work with various
<a name="line-266"></a>    combinations of 'Producer's, 'Consumer's, 'Pipe's, and 'Effect's.  Each
<a name="line-267"></a>    function really has just one general type, which you can then simplify down
<a name="line-268"></a>    to multiple useful alternative types.
<a name="line-269"></a>
<a name="line-270"></a>    Here's an example use of a 'for' @loop@, where the second argument (the
<a name="line-271"></a>    loop body) is an 'Effect':
<a name="line-272"></a>
<a name="line-273"></a>&gt; -- echo.hs
<a name="line-274"></a>&gt;
<a name="line-275"></a>&gt; loop :: Effect IO ()
<a name="line-276"></a>&gt; loop = for stdinLn $ \str -&gt; do  -- Read this like: "for str in stdinLn"
<a name="line-277"></a>&gt;     lift $ putStrLn str          -- The body of the 'for' loop
<a name="line-278"></a>&gt;
<a name="line-279"></a>&gt; -- more concise: loop = for stdinLn (lift . putStrLn)
<a name="line-280"></a>
<a name="line-281"></a>    In this example, 'for' loops over @stdinLn@ and replaces every 'yield' in
<a name="line-282"></a>    @stdinLn@ with the body of the loop, printing each line.  This is exactly
<a name="line-283"></a>    equivalent to the following code, which I've placed side-by-side with the
<a name="line-284"></a>    original definition of @stdinLn@ for comparison:
<a name="line-285"></a>
<a name="line-286"></a>&gt; loop = do                      |  stdinLn = do
<a name="line-287"></a>&gt;     eof &lt;- lift isEOF          |      eof &lt;- lift isEOF
<a name="line-288"></a>&gt;     unless eof $ do            |      unless eof $ do
<a name="line-289"></a>&gt;         str &lt;- lift getLine    |          str &lt;- lift getLine
<a name="line-290"></a>&gt;         (lift . putStrLn) str  |          yield str
<a name="line-291"></a>&gt;         loop                   |          stdinLn
<a name="line-292"></a>
<a name="line-293"></a>    You can think of 'yield' as creating a hole and a 'for' loop is one way to
<a name="line-294"></a>    fill that hole.
<a name="line-295"></a>
<a name="line-296"></a>    Notice how the final @loop@ only 'lift's actions from the base monad and
<a name="line-297"></a>    does nothing else.  This property is true for all 'Effect's, which are just
<a name="line-298"></a>    glorified wrappers around actions in the base monad.  This means we can run
<a name="line-299"></a>    these 'Effect's to remove their 'lift's and lower them back to the
<a name="line-300"></a>    equivalent computation in the base monad:
<a name="line-301"></a>
<a name="line-302"></a>@
<a name="line-303"></a> 'runEffect' :: 'Monad' m =&gt; 'Effect' m r -&gt; m r
<a name="line-304"></a>@
<a name="line-305"></a>
<a name="line-306"></a>    This is the real type signature of 'runEffect', which refuses to accept
<a name="line-307"></a>    anything other than an 'Effect'.  This ensures that we handle all inputs and
<a name="line-308"></a>    outputs before streaming data:
<a name="line-309"></a>
<a name="line-310"></a>&gt; -- echo.hs
<a name="line-311"></a>&gt;
<a name="line-312"></a>&gt; main :: IO ()
<a name="line-313"></a>&gt; main = runEffect loop
<a name="line-314"></a>
<a name="line-315"></a>    ... or you could inline the entire @loop@ into the following one-liner:
<a name="line-316"></a>
<a name="line-317"></a>&gt; main = runEffect $ for stdinLn (lift . putStrLn)
<a name="line-318"></a>
<a name="line-319"></a>    Our final program loops over standard input and echoes every line to
<a name="line-320"></a>    standard output until we hit @Ctrl-D@ to end the input stream:
<a name="line-321"></a>
<a name="line-322"></a>&gt; $ ghc -O2 echo.hs
<a name="line-323"></a>&gt; $ ./echo
<a name="line-324"></a>&gt; Test&lt;Enter&gt;
<a name="line-325"></a>&gt; Test
<a name="line-326"></a>&gt; ABC&lt;Enter&gt;
<a name="line-327"></a>&gt; ABC
<a name="line-328"></a>&gt; &lt;Ctrl-D&gt;
<a name="line-329"></a>&gt; $
<a name="line-330"></a>
<a name="line-331"></a>    The final behavior is indistinguishable from just removing all the 'lift's
<a name="line-332"></a>    from @loop@:
<a name="line-333"></a>
<a name="line-334"></a>&gt; main = do               |  loop = do
<a name="line-335"></a>&gt;     eof &lt;- isEof        |      eof &lt;- lift isEof
<a name="line-336"></a>&gt;     unless eof $ do     |      unless eof $ do
<a name="line-337"></a>&gt;         str &lt;- getLine  |          str &lt;- lift getLine
<a name="line-338"></a>&gt;         putStrLn str    |          (lift . putStrLn) str
<a name="line-339"></a>&gt;         main            |          loop
<a name="line-340"></a>
<a name="line-341"></a>    This @main@ is what we might have written by hand if we were not using
<a name="line-342"></a>    @pipes@, but with @pipes@ we can decouple the input and output logic from
<a name="line-343"></a>    each other.  When we connect them back together, we still produce streaming
<a name="line-344"></a>    code equivalent to what a sufficiently careful Haskell programmer would
<a name="line-345"></a>    have written.
<a name="line-346"></a>
<a name="line-347"></a>    You can also use 'for' to loop over lists, too.  To do so, convert the list
<a name="line-348"></a>    to a 'Producer' using 'each', which is exported by default from "Pipes":
<a name="line-349"></a>
<a name="line-350"></a>&gt; each :: Monad m =&gt; [a] -&gt; Producer a m ()
<a name="line-351"></a>&gt; each as = mapM_ yield as
<a name="line-352"></a>
<a name="line-353"></a>    Combine 'for' and 'each' to iterate over lists using a \"foreach\" loop:
<a name="line-354"></a>
<a name="line-355"></a>&gt;&gt;&gt; runEffect $ for (each [1..4]) (lift . print)
<a name="line-356"></a>1
<a name="line-357"></a>2
<a name="line-358"></a>3
<a name="line-359"></a>4
<a name="line-360"></a>
<a name="line-361"></a>    'each' is actually more general and works for any 'Foldable':
<a name="line-362"></a>
<a name="line-363"></a>@
<a name="line-364"></a> 'each' :: ('Monad' m, 'Foldable' f) =&gt; f a -&gt; 'Producer' a m ()
<a name="line-365"></a>@
<a name="line-366"></a>
<a name="line-367"></a>     So you can loop over any 'Foldable' container or even a 'Maybe':
<a name="line-368"></a>
<a name="line-369"></a>&gt;&gt;&gt; runEffect $ for (each (Just 1)) (lift . print)
<a name="line-370"></a>1
<a name="line-371"></a>
<a name="line-372"></a>-}</span>
<a name="line-373"></a>
<a name="line-374"></a><span class='hs-comment'>{- $composability
<a name="line-375"></a>    You might wonder why the body of a 'for' loop can be a 'Producer'.  Let's
<a name="line-376"></a>    test out this feature by defining a new loop body that @duplicate@s every
<a name="line-377"></a>    value:
<a name="line-378"></a>
<a name="line-379"></a>&gt; -- nested.hs
<a name="line-380"></a>&gt;
<a name="line-381"></a>&gt; import Pipes
<a name="line-382"></a>&gt; import qualified Pipes.Prelude as P  -- Pipes.Prelude already has 'stdinLn'
<a name="line-383"></a>&gt; 
<a name="line-384"></a>&gt; duplicate :: Monad m =&gt; a -&gt; Producer a m ()
<a name="line-385"></a>&gt; duplicate x = do
<a name="line-386"></a>&gt;     yield x
<a name="line-387"></a>&gt;     yield x
<a name="line-388"></a>&gt;
<a name="line-389"></a>&gt; loop :: Producer String IO ()
<a name="line-390"></a>&gt; loop = for P.stdinLn duplicate
<a name="line-391"></a>&gt;
<a name="line-392"></a>&gt; -- This is the exact same as:
<a name="line-393"></a>&gt; --
<a name="line-394"></a>&gt; -- loop = for P.stdinLn $ \x -&gt; do
<a name="line-395"></a>&gt; --     yield x
<a name="line-396"></a>&gt; --     yield x
<a name="line-397"></a>
<a name="line-398"></a>    This time our @loop@ is a 'Producer' that outputs 'String's, specifically
<a name="line-399"></a>    two copies of each line that we read from standard input.  Since @loop@ is a
<a name="line-400"></a>    'Producer' we cannot run it because there is still unhandled output.
<a name="line-401"></a>    However, we can use yet another 'for' to handle this new duplicated stream:
<a name="line-402"></a>
<a name="line-403"></a>&gt; -- nested.hs
<a name="line-404"></a>&gt;
<a name="line-405"></a>&gt; main = runEffect $ for loop (lift . putStrLn)
<a name="line-406"></a>
<a name="line-407"></a>    This creates a program which echoes every line from standard input to
<a name="line-408"></a>    standard output twice:
<a name="line-409"></a>
<a name="line-410"></a>&gt; $ ./nested
<a name="line-411"></a>&gt; Test&lt;Enter&gt;
<a name="line-412"></a>&gt; Test
<a name="line-413"></a>&gt; Test
<a name="line-414"></a>&gt; ABC&lt;Enter&gt;
<a name="line-415"></a>&gt; ABC
<a name="line-416"></a>&gt; ABC
<a name="line-417"></a>&gt; &lt;Ctrl-D&gt;
<a name="line-418"></a>&gt; $
<a name="line-419"></a>
<a name="line-420"></a>    But is this really necessary?  Couldn't we have instead written this using a
<a name="line-421"></a>    nested for loop?
<a name="line-422"></a>
<a name="line-423"></a>&gt; main = runEffect $
<a name="line-424"></a>&gt;     for P.stdinLn $ \str1 -&gt;
<a name="line-425"></a>&gt;         for (duplicate str1) $ \str2 -&gt;
<a name="line-426"></a>&gt;             lift $ putStrLn str2
<a name="line-427"></a>
<a name="line-428"></a>    Yes, we could have!  In fact, this is a special case of the following
<a name="line-429"></a>    equality, which always holds no matter what:
<a name="line-430"></a>
<a name="line-431"></a>@
<a name="line-432"></a> \-\- s :: Monad m =&gt;      'Producer' a m ()  -- i.e. \'P.stdinLn\'
<a name="line-433"></a> \-\- f :: Monad m =&gt; a -&gt; 'Producer' b m ()  -- i.e. \'duplicate\'
<a name="line-434"></a> \-\- g :: Monad m =&gt; b -&gt; 'Producer' c m ()  -- i.e. \'(lift . putStrLn)\'
<a name="line-435"></a>
<a name="line-436"></a>\ for (for s f) g = for s (\\x -&gt; for (f x) g)
<a name="line-437"></a>@
<a name="line-438"></a>
<a name="line-439"></a>    We can understand the rationale behind this equality if we first define the
<a name="line-440"></a>    following operator that is the point-free counterpart to 'for':
<a name="line-441"></a>
<a name="line-442"></a>@
<a name="line-443"></a> (~&gt;) :: Monad m
<a name="line-444"></a>      =&gt; (a -&gt; 'Producer' b m ())
<a name="line-445"></a>      -&gt; (b -&gt; 'Producer' c m ())
<a name="line-446"></a>      -&gt; (a -&gt; 'Producer' c m ())
<a name="line-447"></a> (f ~&gt; g) x = for (f x) g
<a name="line-448"></a>@
<a name="line-449"></a>
<a name="line-450"></a>    Using ('~&gt;') (pronounced \"into\"), we can transform our original equality
<a name="line-451"></a>    into the following more symmetric equation:
<a name="line-452"></a>
<a name="line-453"></a>@
<a name="line-454"></a> f :: Monad m =&gt; a -&gt; 'Producer' b m ()
<a name="line-455"></a> g :: Monad m =&gt; b -&gt; 'Producer' c m ()
<a name="line-456"></a> h :: Monad m =&gt; c -&gt; 'Producer' d m ()
<a name="line-457"></a>
<a name="line-458"></a>\ \-\- Associativity
<a name="line-459"></a> (f ~&gt; g) ~&gt; h = f ~&gt; (g ~&gt; h)
<a name="line-460"></a>@
<a name="line-461"></a>
<a name="line-462"></a>    This looks just like an associativity law.  In fact, ('~&gt;') has another nice
<a name="line-463"></a>    property, which is that 'yield' is its left and right identity:
<a name="line-464"></a>
<a name="line-465"></a>&gt; -- Left Identity
<a name="line-466"></a>&gt; yield ~&gt; f = f
<a name="line-467"></a>
<a name="line-468"></a>&gt; -- Right Identity
<a name="line-469"></a>&gt; f ~&gt; yield = f
<a name="line-470"></a>
<a name="line-471"></a>    In other words, 'yield' and ('~&gt;') form a 'Category', specifically the
<a name="line-472"></a>    generator category, where ('~&gt;') plays the role of the composition operator
<a name="line-473"></a>    and 'yield' is the identity.  If you don't know what a 'Category' is, that's
<a name="line-474"></a>    okay, and category theory is not a prerequisite for using @pipes@.  All you
<a name="line-475"></a>    really need to know is that @pipes@ uses some simple category theory to keep
<a name="line-476"></a>    the API intuitive and easy to use.
<a name="line-477"></a>
<a name="line-478"></a>    Notice that if we translate the left identity law to use 'for' instead of
<a name="line-479"></a>    ('~&gt;') we get:
<a name="line-480"></a>
<a name="line-481"></a>&gt; for (yield x) f = f x
<a name="line-482"></a>
<a name="line-483"></a>    This just says that if you iterate over a pure single-element 'Producer',
<a name="line-484"></a>    then you could instead cut out the middle man and directly apply the body of
<a name="line-485"></a>    the loop to that single element.
<a name="line-486"></a>
<a name="line-487"></a>    If we translate the right identity law to use 'for' instead of ('~&gt;') we
<a name="line-488"></a>    get:
<a name="line-489"></a>
<a name="line-490"></a>&gt; for s yield = s
<a name="line-491"></a>
<a name="line-492"></a>    This just says that if the only thing you do is re-'yield' every element of
<a name="line-493"></a>    a stream, you get back your original stream.
<a name="line-494"></a>
<a name="line-495"></a>    These three \"for loop\" laws summarize our intuition for how 'for' loops
<a name="line-496"></a>    should behave and because these are 'Category' laws in disguise that means
<a name="line-497"></a>    that 'Producer's are composable in a rigorous sense of the word.
<a name="line-498"></a>
<a name="line-499"></a>    In fact, we get more out of this than just a bunch of equations.  We also
<a name="line-500"></a>    get a useful operator: ('~&gt;').  We can use this operator to condense
<a name="line-501"></a>    our original code into the following more succinct form that composes two
<a name="line-502"></a>    transformations:
<a name="line-503"></a>
<a name="line-504"></a>&gt; main = runEffect $ for P.stdinLn (duplicate ~&gt; lift . putStrLn)
<a name="line-505"></a>
<a name="line-506"></a>    This means that we can also choose to program in a more functional style and
<a name="line-507"></a>    think of stream processing in terms of composing transformations using
<a name="line-508"></a>    ('~&gt;') instead of nesting a bunch of 'for' loops.
<a name="line-509"></a>
<a name="line-510"></a>    The above example is a microcosm of the design philosophy behind the @pipes@
<a name="line-511"></a>    library:
<a name="line-512"></a>
<a name="line-513"></a>    * Define the API in terms of categories
<a name="line-514"></a>
<a name="line-515"></a>    * Specify expected behavior in terms of category laws
<a name="line-516"></a>
<a name="line-517"></a>    * Think compositionally instead of sequentially
<a name="line-518"></a>-}</span>
<a name="line-519"></a>
<a name="line-520"></a><span class='hs-comment'>{- $consumers
<a name="line-521"></a>    Sometimes you don't want to use a 'for' loop because you don't want to consume
<a name="line-522"></a>    every element of a 'Producer' or because you don't want to process every
<a name="line-523"></a>    value of a 'Producer' the exact same way.
<a name="line-524"></a>
<a name="line-525"></a>    The most general solution is to externally iterate over the 'Producer' using
<a name="line-526"></a>    the 'next' command:
<a name="line-527"></a>
<a name="line-528"></a>@
<a name="line-529"></a> 'next' :: 'Monad' m =&gt; 'Producer' a m r -&gt; m ('Either' r (a, 'Producer' a m r))
<a name="line-530"></a>@
<a name="line-531"></a>
<a name="line-532"></a>    Think of 'next' as pattern matching on the head of the 'Producer'.  This
<a name="line-533"></a>    'Either' returns a 'Left' if the 'Producer' is done or it returns a 'Right'
<a name="line-534"></a>    containing the next value, @a@, along with the remainder of the 'Producer'.
<a name="line-535"></a>
<a name="line-536"></a>    However, sometimes we can get away with something a little more simple and
<a name="line-537"></a>    elegant, like a 'Consumer', which represents an effectful sink of values.  A
<a name="line-538"></a>    'Consumer' is a monad transformer that extends the base monad with a new
<a name="line-539"></a>    'await' command. This 'await' command lets you receive input from an
<a name="line-540"></a>    anonymous upstream source.
<a name="line-541"></a>
<a name="line-542"></a>    The following @stdoutLn@ 'Consumer' shows how to incrementally 'await'
<a name="line-543"></a>    'String's and print them to standard output, terminating gracefully when
<a name="line-544"></a>    receiving a broken pipe error:
<a name="line-545"></a>
<a name="line-546"></a>&gt; import Control.Monad (unless)
<a name="line-547"></a>&gt; import Control.Exception (try, throwIO)
<a name="line-548"></a>&gt; import qualified GHC.IO.Exception as G
<a name="line-549"></a>&gt; import Pipes
<a name="line-550"></a>&gt;
<a name="line-551"></a>&gt; --          +--------+-- A 'Consumer' that awaits 'String's
<a name="line-552"></a>&gt; --          |        |
<a name="line-553"></a>&gt; --          v        v
<a name="line-554"></a>&gt; stdoutLn :: Consumer String IO ()
<a name="line-555"></a>&gt; stdoutLn = do
<a name="line-556"></a>&gt;     str &lt;- await  -- 'await' a 'String'
<a name="line-557"></a>&gt;     x   &lt;- lift $ try $ putStrLn str
<a name="line-558"></a>&gt;     case x of
<a name="line-559"></a>&gt;         -- Gracefully terminate if we got a broken pipe error
<a name="line-560"></a>&gt;         Left e@(G.IOError { G.ioe_type = t}) -&gt;
<a name="line-561"></a>&gt;             lift $ unless (t == G.ResourceVanished) $ throwIO e
<a name="line-562"></a>&gt;         -- Otherwise loop
<a name="line-563"></a>&gt;         Right () -&gt; stdoutLn
<a name="line-564"></a>
<a name="line-565"></a>    'await' is the dual of 'yield': we suspend our 'Consumer' until we receive a
<a name="line-566"></a>    new value.  If nobody provides a value (which is possible) then 'await'
<a name="line-567"></a>    never returns.  You can think of 'await' as having the following type:
<a name="line-568"></a>
<a name="line-569"></a>@
<a name="line-570"></a> 'await' :: 'Monad' m =&gt; 'Consumer' a m a
<a name="line-571"></a>@
<a name="line-572"></a>
<a name="line-573"></a>    One way to feed a 'Consumer' is to repeatedly feed the same input using
<a name="line-574"></a>    ('&gt;~') (pronounced \"feed\"):
<a name="line-575"></a>
<a name="line-576"></a>@
<a name="line-577"></a> \-\-                 +- Feed       +- Consumer to    +- Returns new
<a name="line-578"></a> \-\-                 |  action     |  feed           |  Effect
<a name="line-579"></a> \-\-                 v             v                 v  
<a name="line-580"></a> \-\-                 ----------    --------------    ----------
<a name="line-581"></a> ('&gt;~') :: 'Monad' m =&gt; 'Effect' m b -&gt; 'Consumer' b m c -&gt; 'Effect' m c
<a name="line-582"></a>@
<a name="line-583"></a>
<a name="line-584"></a>    @(draw &gt;~ consumer)@ loops over @(consumer)@, substituting each 'await' in
<a name="line-585"></a>    @(consumer)@ with @(draw)@.
<a name="line-586"></a>
<a name="line-587"></a>    So the following code replaces every 'await' in 'P.stdoutLn' with
<a name="line-588"></a>    @(lift getLine)@ and then removes all the 'lift's:
<a name="line-589"></a>
<a name="line-590"></a>&gt;&gt;&gt; runEffect $ lift getLine &gt;~ stdoutLn
<a name="line-591"></a>Test&lt;Enter&gt;
<a name="line-592"></a>Test
<a name="line-593"></a>ABC&lt;Enter&gt;
<a name="line-594"></a>ABC
<a name="line-595"></a>42&lt;Enter&gt;
<a name="line-596"></a>42
<a name="line-597"></a>...
<a name="line-598"></a>
<a name="line-599"></a>    You might wonder why ('&gt;~') uses an 'Effect' instead of a raw action in the
<a name="line-600"></a>    base monad.  The reason why is that ('&gt;~') actually permits the following
<a name="line-601"></a>    more general type:
<a name="line-602"></a>
<a name="line-603"></a>@
<a name="line-604"></a> ('&gt;~') :: 'Monad' m =&gt; 'Consumer' a m b -&gt; 'Consumer' b m c -&gt; 'Consumer' a m c
<a name="line-605"></a>@
<a name="line-606"></a>
<a name="line-607"></a>    ('&gt;~') is the dual of ('~&gt;'), composing 'Consumer's instead of 'Producer's.
<a name="line-608"></a>
<a name="line-609"></a>    This means that you can feed a 'Consumer' with yet another 'Consumer' so
<a name="line-610"></a>    that you can 'await' while you 'await'.  For example, we could define the
<a name="line-611"></a>    following intermediate 'Consumer' that requests two 'String's and returns
<a name="line-612"></a>    them concatenated:
<a name="line-613"></a>
<a name="line-614"></a>&gt; doubleUp :: Monad m =&gt; Consumer String m String
<a name="line-615"></a>&gt; doubleUp = do
<a name="line-616"></a>&gt;     str1 &lt;- await
<a name="line-617"></a>&gt;     str2 &lt;- await
<a name="line-618"></a>&gt;     return (str1 ++ str2)
<a name="line-619"></a>&gt;
<a name="line-620"></a>&gt; -- more concise: doubleUp = (++) &lt;$&gt; await &lt;*&gt; await
<a name="line-621"></a>
<a name="line-622"></a>    We can now insert this in between @(lift getLine)@ and @stdoutLn@ and see
<a name="line-623"></a>    what happens:
<a name="line-624"></a>
<a name="line-625"></a>&gt;&gt;&gt; runEffect $ lift getLine &gt;~ doubleUp &gt;~ stdoutLn
<a name="line-626"></a>Test&lt;Enter&gt;
<a name="line-627"></a>ing&lt;Enter&gt;
<a name="line-628"></a>Testing
<a name="line-629"></a>ABC&lt;Enter&gt;
<a name="line-630"></a>DEF&lt;Enter&gt;
<a name="line-631"></a>ABCDEF
<a name="line-632"></a>42&lt;Enter&gt;
<a name="line-633"></a>000&lt;Enter&gt;
<a name="line-634"></a>42000
<a name="line-635"></a>...
<a name="line-636"></a>
<a name="line-637"></a>    'doubleUp' splits every request from 'stdoutLn' into two separate requests
<a name="line-638"></a>    and
<a name="line-639"></a>    returns back the concatenated result.
<a name="line-640"></a>
<a name="line-641"></a>    We didn't need to parenthesize the above chain of ('&gt;~') operators, because
<a name="line-642"></a>    ('&gt;~') is associative:
<a name="line-643"></a>
<a name="line-644"></a>&gt; -- Associativity
<a name="line-645"></a>&gt; (f &gt;~ g) &gt;~ h = f &gt;~ (g &gt;~ h)
<a name="line-646"></a>
<a name="line-647"></a>    ... so we can always omit the parentheses since the meaning is unambiguous:
<a name="line-648"></a>
<a name="line-649"></a>&gt; f &gt;~ g &gt;~ h
<a name="line-650"></a>
<a name="line-651"></a>    Also, ('&gt;~') has an identity, which is 'await'!
<a name="line-652"></a>
<a name="line-653"></a>&gt; -- Left identity
<a name="line-654"></a>&gt; await &gt;~ f = f
<a name="line-655"></a>&gt;
<a name="line-656"></a>&gt; -- Right Identity
<a name="line-657"></a>&gt; f &gt;~ await = f
<a name="line-658"></a>
<a name="line-659"></a>    In other words, ('&gt;~') and 'await' form a 'Category', too, specifically the
<a name="line-660"></a>    iteratee category, and 'Consumer's are also composable.
<a name="line-661"></a>-}</span>
<a name="line-662"></a>
<a name="line-663"></a><span class='hs-comment'>{- $pipes
<a name="line-664"></a>    Our previous programs were unsatisfactory because they were biased either
<a name="line-665"></a>    towards the 'Producer' end or the 'Consumer' end.  As a result, we had to
<a name="line-666"></a>    choose between gracefully handling end of input (using 'P.stdinLn') or
<a name="line-667"></a>    gracefully handling end of output (using 'P.stdoutLn'), but not both at the
<a name="line-668"></a>    same time.
<a name="line-669"></a>
<a name="line-670"></a>    However, we don't need to restrict ourselves to using 'Producer's
<a name="line-671"></a>    exclusively or 'Consumer's exclusively.  We can connect 'Producer's and
<a name="line-672"></a>    'Consumer's directly together using ('&gt;-&gt;') (pronounced \"pipe\"):
<a name="line-673"></a>
<a name="line-674"></a>@
<a name="line-675"></a> ('&gt;-&gt;') :: 'Monad' m =&gt; 'Producer' a m r -&gt; 'Consumer' a m r -&gt; 'Effect' m r
<a name="line-676"></a>@
<a name="line-677"></a>
<a name="line-678"></a>    This returns an 'Effect' which we can run:
<a name="line-679"></a>
<a name="line-680"></a>&gt; -- echo2.hs
<a name="line-681"></a>&gt;
<a name="line-682"></a>&gt; import Pipes
<a name="line-683"></a>&gt; import qualified Pipes.Prelude as P  -- Pipes.Prelude also provides 'stdoutLn'
<a name="line-684"></a>&gt;
<a name="line-685"></a>&gt; main = runEffect $ P.stdinLn &gt;-&gt; P.stdoutLn
<a name="line-686"></a>
<a name="line-687"></a>    This program is more declarative of our intent: we want to stream values
<a name="line-688"></a>    from 'P.stdinLn' to 'P.stdoutLn'.  The above \"pipeline\" not only echoes
<a name="line-689"></a>    standard input to standard output, but also handles both end of input and
<a name="line-690"></a>    broken pipe errors:
<a name="line-691"></a>
<a name="line-692"></a>&gt; $ ./echo2
<a name="line-693"></a>&gt; Test&lt;Enter&gt;
<a name="line-694"></a>&gt; Test
<a name="line-695"></a>&gt; ABC&lt;Enter&gt;
<a name="line-696"></a>&gt; ABC
<a name="line-697"></a>&gt; 42&lt;Enter&gt;
<a name="line-698"></a>&gt; 42
<a name="line-699"></a>&gt; &lt;Ctrl-D&gt;
<a name="line-700"></a>&gt; $
<a name="line-701"></a>
<a name="line-702"></a>    ('&gt;-&gt;') is \"pull-based\" meaning that control flow begins at the most
<a name="line-703"></a>    downstream component (i.e. 'P.stdoutLn' in the above example).  Any time a
<a name="line-704"></a>    component 'await's a value it blocks and transfers control upstream and
<a name="line-705"></a>    every time a component 'yield's a value it blocks and restores control back
<a name="line-706"></a>    downstream, satisfying the 'await'.  So in the above example, ('&gt;-&gt;')
<a name="line-707"></a>    matches every 'await' from 'P.stdoutLn' with a 'yield' from 'P.stdinLn'.
<a name="line-708"></a>
<a name="line-709"></a>    Streaming stops when either 'P.stdinLn' terminates (i.e. end of input) or
<a name="line-710"></a>    'P.stdoutLn' terminates (i.e. broken pipe).  This is why ('&gt;-&gt;') requires
<a name="line-711"></a>    that both the 'Producer' and 'Consumer' share the same type of return value:
<a name="line-712"></a>    whichever one terminates first provides the return value for the entire
<a name="line-713"></a>    'Effect'.
<a name="line-714"></a>
<a name="line-715"></a>    Let's test this by modifying our 'Producer' and 'Consumer' to each return a
<a name="line-716"></a>    diagnostic 'String':
<a name="line-717"></a>
<a name="line-718"></a>&gt; -- echo3.hs
<a name="line-719"></a>&gt;
<a name="line-720"></a>&gt; import Control.Applicative ((&lt;$))  -- (&lt;$) modifies return values
<a name="line-721"></a>&gt; import Pipes
<a name="line-722"></a>&gt; import qualified Pipes.Prelude as P
<a name="line-723"></a>&gt; import System.IO
<a name="line-724"></a>&gt;
<a name="line-725"></a>&gt; main = do
<a name="line-726"></a>&gt;     hSetBuffering stdout NoBuffering
<a name="line-727"></a>&gt;     str &lt;- runEffect $
<a name="line-728"></a>&gt;         ("End of input!" &lt;$ P.stdinLn) &gt;-&gt; ("Broken pipe!" &lt;$ P.stdoutLn)
<a name="line-729"></a>&gt;     hPutStrLn stderr str
<a name="line-730"></a>
<a name="line-731"></a>    This lets us diagnose whether the 'Producer' or 'Consumer' terminated first:
<a name="line-732"></a>
<a name="line-733"></a>&gt; $ ./echo3
<a name="line-734"></a>&gt; Test&lt;Enter&gt;
<a name="line-735"></a>&gt; Test
<a name="line-736"></a>&gt; &lt;Ctrl-D&gt;
<a name="line-737"></a>&gt; End of input!
<a name="line-738"></a>&gt; $ ./echo3 | perl -e 'close STDIN'
<a name="line-739"></a>&gt; Test&lt;Enter&gt;
<a name="line-740"></a>&gt; Broken pipe!
<a name="line-741"></a>&gt; $
<a name="line-742"></a>
<a name="line-743"></a>    You might wonder why ('&gt;-&gt;') returns an 'Effect' that we have to run instead
<a name="line-744"></a>    of directly returning an action in the base monad.  This is because you can
<a name="line-745"></a>    connect things other than 'Producer's and 'Consumer's, like 'Pipe's, which
<a name="line-746"></a>    are effectful stream transformations.
<a name="line-747"></a>
<a name="line-748"></a>    A 'Pipe' is a monad transformer that is a mix between a 'Producer' and
<a name="line-749"></a>    'Consumer', because a 'Pipe' can both 'await' and 'yield'.  The following
<a name="line-750"></a>    example 'Pipe' is analagous to the Prelude's 'take', only allowing a fixed
<a name="line-751"></a>    number of values to flow through:
<a name="line-752"></a>
<a name="line-753"></a>&gt; -- take.hs
<a name="line-754"></a>&gt;
<a name="line-755"></a>&gt; import Control.Monad (replicateM_)
<a name="line-756"></a>&gt; import Pipes
<a name="line-757"></a>&gt; import Prelude hiding (take)
<a name="line-758"></a>&gt;
<a name="line-759"></a>&gt; --              +--------- A 'Pipe' that
<a name="line-760"></a>&gt; --              |    +---- 'await's 'a's and
<a name="line-761"></a>&gt; --              |    | +-- 'yield's 'a's
<a name="line-762"></a>&gt; --              |    | |
<a name="line-763"></a>&gt; --              v    v v
<a name="line-764"></a>&gt; take ::  Int -&gt; Pipe a a IO ()
<a name="line-765"></a>&gt; take n = do
<a name="line-766"></a>&gt;     replicateM_ n $ do                     -- Repeat this block 'n' times
<a name="line-767"></a>&gt;         x &lt;- await                         -- 'await' a value of type 'a'
<a name="line-768"></a>&gt;         yield x                            -- 'yield' a value of type 'a'
<a name="line-769"></a>&gt;     lift $ putStrLn "You shall not pass!"  -- Fly, you fools!
<a name="line-770"></a>
<a name="line-771"></a>    You can use 'Pipe's to transform 'Producer's, 'Consumer's, or even other
<a name="line-772"></a>    'Pipe's using the same ('&gt;-&gt;') operator:
<a name="line-773"></a>
<a name="line-774"></a>@
<a name="line-775"></a> ('&gt;-&gt;') :: 'Monad' m =&gt; 'Producer' a m r -&gt; 'Pipe'   a b m r -&gt; 'Producer' b m r
<a name="line-776"></a> ('&gt;-&gt;') :: 'Monad' m =&gt; 'Pipe'   a b m r -&gt; 'Consumer' b m r -&gt; 'Consumer' a m r
<a name="line-777"></a> ('&gt;-&gt;') :: 'Monad' m =&gt; 'Pipe'   a b m r -&gt; 'Pipe'   b c m r -&gt; 'Pipe'   a c m r
<a name="line-778"></a>@
<a name="line-779"></a>
<a name="line-780"></a>    For example, you can compose 'P.take' after 'P.stdinLn' to limit the number
<a name="line-781"></a>    of lines drawn from standard input:
<a name="line-782"></a>
<a name="line-783"></a>&gt; maxInput :: Int -&gt; Producer String IO ()
<a name="line-784"></a>&gt; maxInput n = P.stdinLn &gt;-&gt; take n
<a name="line-785"></a>
<a name="line-786"></a>&gt;&gt;&gt; runEffect $ maxInput 3 &gt;-&gt; P.stdoutLn
<a name="line-787"></a>Test&lt;Enter&gt;
<a name="line-788"></a>Test
<a name="line-789"></a>ABC&lt;Enter&gt;
<a name="line-790"></a>ABC
<a name="line-791"></a>42&lt;Enter&gt;
<a name="line-792"></a>42
<a name="line-793"></a>You shall not pass!
<a name="line-794"></a>&gt;&gt;&gt;
<a name="line-795"></a>
<a name="line-796"></a>    ... or you can pre-compose 'P.take' before 'P.stdoutLn' to limit the number
<a name="line-797"></a>    of lines written to standard output:
<a name="line-798"></a>
<a name="line-799"></a>&gt; maxOutput :: Int -&gt; Consumer String IO ()
<a name="line-800"></a>&gt; maxOutput n = take n &gt;-&gt; P.stdoutLn
<a name="line-801"></a>
<a name="line-802"></a>&gt;&gt;&gt; runEffect $ P.stdinLn &gt;-&gt; maxOutput 3
<a name="line-803"></a>&lt;Exact same behavior&gt;
<a name="line-804"></a>
<a name="line-805"></a>    Those both gave the same behavior because ('&gt;-&gt;') is associative:
<a name="line-806"></a>
<a name="line-807"></a>&gt; (p1 &gt;-&gt; p2) &gt;-&gt; p3 = p1 &gt;-&gt; (p2 &gt;-&gt; p3)
<a name="line-808"></a>
<a name="line-809"></a>    Therefore we can just leave out the parentheses:
<a name="line-810"></a>
<a name="line-811"></a>&gt;&gt;&gt; runEffect $ P.stdinLn &gt;-&gt; take 3 &gt;-&gt; P.stdoutLn
<a name="line-812"></a>&lt;Exact same behavior&gt;
<a name="line-813"></a>
<a name="line-814"></a>    ('&gt;-&gt;') is designed to behave like the Unix pipe operator, except with less
<a name="line-815"></a>    quirks.  In fact, we can continue the analogy to Unix by defining 'cat'
<a name="line-816"></a>    (named after the Unix @cat@ utility), which reforwards elements endlessly:
<a name="line-817"></a>
<a name="line-818"></a>&gt; cat :: Monad m =&gt; Pipe a a m r
<a name="line-819"></a>&gt; cat = forever $ do
<a name="line-820"></a>&gt;     x &lt;- await
<a name="line-821"></a>&gt;     yield x
<a name="line-822"></a>
<a name="line-823"></a>     'cat' is the identity of ('&gt;-&gt;'), meaning that 'cat' satisfies the
<a name="line-824"></a>     following two laws:
<a name="line-825"></a>
<a name="line-826"></a>&gt; -- Useless use of 'cat'
<a name="line-827"></a>&gt; cat &gt;-&gt; p = p
<a name="line-828"></a>&gt;
<a name="line-829"></a>&gt; -- Forwarding output to 'cat' does nothing
<a name="line-830"></a>&gt; p &gt;-&gt; cat = p
<a name="line-831"></a>
<a name="line-832"></a>    Therefore, ('&gt;-&gt;') and 'cat' form a 'Category', specifically the category of
<a name="line-833"></a>    Unix pipes, and 'Pipe's are also composable.
<a name="line-834"></a>
<a name="line-835"></a>    A lot of Unix tools have very simple definitions when written using @pipes@:
<a name="line-836"></a>
<a name="line-837"></a>&gt; -- unix.hs
<a name="line-838"></a>&gt;
<a name="line-839"></a>&gt; import Control.Monad (forever)
<a name="line-840"></a>&gt; import Pipes
<a name="line-841"></a>&gt; import qualified Pipes.Prelude as P  -- Pipes.Prelude provides 'take', too
<a name="line-842"></a>&gt; import Prelude hiding (head)
<a name="line-843"></a>&gt;
<a name="line-844"></a>&gt; head :: Monad m =&gt; Int -&gt; Pipe a a m ()
<a name="line-845"></a>&gt; head = P.take
<a name="line-846"></a>&gt;
<a name="line-847"></a>&gt; yes :: Monad m =&gt; Producer String m r
<a name="line-848"></a>&gt; yes = forever $ yield "y"
<a name="line-849"></a>&gt;
<a name="line-850"></a>&gt; main = runEffect $ yes &gt;-&gt; head 3 &gt;-&gt; P.stdoutLn
<a name="line-851"></a>
<a name="line-852"></a>    This prints out 3 \'@y@\'s, just like the equivalent Unix pipeline:
<a name="line-853"></a>
<a name="line-854"></a>&gt; $ ./unix
<a name="line-855"></a>&gt; y
<a name="line-856"></a>&gt; y
<a name="line-857"></a>&gt; y
<a name="line-858"></a>&gt; $ yes | head -3
<a name="line-859"></a>&gt; y
<a name="line-860"></a>&gt; y
<a name="line-861"></a>&gt; y
<a name="line-862"></a>&gt; $
<a name="line-863"></a>
<a name="line-864"></a>    This lets us write \"Haskell pipes\" instead of Unix pipes.  These are much
<a name="line-865"></a>    easier to build than Unix pipes and we can connect them directly within
<a name="line-866"></a>    Haskell for interoperability with the Haskell language and ecosystem.
<a name="line-867"></a>-}</span>
<a name="line-868"></a>
<a name="line-869"></a><span class='hs-comment'>{- $listT
<a name="line-870"></a>    @pipes@ also provides a \"ListT done right\" implementation.  This differs
<a name="line-871"></a>    from the implementation in @transformers@ because this 'ListT':
<a name="line-872"></a>
<a name="line-873"></a>    * obeys the monad laws, and
<a name="line-874"></a>
<a name="line-875"></a>    * streams data immediately instead of collecting all results into memory.
<a name="line-876"></a>
<a name="line-877"></a>    The latter property is actually an elegant consequence of obeying the monad
<a name="line-878"></a>    laws.
<a name="line-879"></a>
<a name="line-880"></a>    To bind a list within a 'ListT' computation, combine 'Select' and 'each':
<a name="line-881"></a>
<a name="line-882"></a>&gt; import Pipes
<a name="line-883"></a>&gt; 
<a name="line-884"></a>&gt; pair :: ListT IO (Int, Int)
<a name="line-885"></a>&gt; pair = do
<a name="line-886"></a>&gt;     x &lt;- Select $ each [1, 2]
<a name="line-887"></a>&gt;     lift $ putStrLn $ "x = " ++ show x
<a name="line-888"></a>&gt;     y &lt;- Select $ each [3, 4]
<a name="line-889"></a>&gt;     lift $ putStrLn $ "y = " ++ show y
<a name="line-890"></a>&gt;     return (x, y)
<a name="line-891"></a>
<a name="line-892"></a>    You can then loop over a 'ListT' by using 'every':
<a name="line-893"></a>
<a name="line-894"></a>@
<a name="line-895"></a> 'every' :: 'Monad' m =&gt; 'ListT' m a -&gt; 'Producer' a m ()
<a name="line-896"></a>@
<a name="line-897"></a>
<a name="line-898"></a>    So you can use your 'ListT' within a 'for' loop:
<a name="line-899"></a>
<a name="line-900"></a>&gt;&gt;&gt; runEffect $ for (every pair) (lift . print)
<a name="line-901"></a>x = 1
<a name="line-902"></a>y = 3
<a name="line-903"></a>(1,3)
<a name="line-904"></a>y = 4
<a name="line-905"></a>(1,4)
<a name="line-906"></a>x = 2
<a name="line-907"></a>y = 3
<a name="line-908"></a>(2,3)
<a name="line-909"></a>y = 4
<a name="line-910"></a>(2,4)
<a name="line-911"></a>
<a name="line-912"></a>    ... or a pipeline:
<a name="line-913"></a>
<a name="line-914"></a>&gt;&gt;&gt; import qualified Pipes.Prelude as P
<a name="line-915"></a>&gt;&gt;&gt; runEffect $ every pair &gt;-&gt; P.print
<a name="line-916"></a>&lt;Exact same behavior&gt;
<a name="line-917"></a>
<a name="line-918"></a>    Note that 'ListT' is lazy and only produces as many elements as we request:
<a name="line-919"></a>
<a name="line-920"></a>&gt;&gt;&gt; runEffect $ for (every pair &gt;-&gt; P.take 2) (lift . print)
<a name="line-921"></a>x = 1
<a name="line-922"></a>y = 3
<a name="line-923"></a>(1,3)
<a name="line-924"></a>y = 4
<a name="line-925"></a>(1,4)
<a name="line-926"></a>
<a name="line-927"></a>    You can also go the other way, binding 'Producer's directly within a
<a name="line-928"></a>    'ListT'.  In fact, this is actually what 'Select' was already doing:
<a name="line-929"></a>
<a name="line-930"></a>@
<a name="line-931"></a> 'Select' :: 'Producer' a m () -&gt; 'ListT' m a
<a name="line-932"></a>@
<a name="line-933"></a>
<a name="line-934"></a>    This lets you write crazy code like:
<a name="line-935"></a>
<a name="line-936"></a>&gt; import Pipes
<a name="line-937"></a>&gt; import qualified Pipes.Prelude as P
<a name="line-938"></a>&gt; 
<a name="line-939"></a>&gt; input :: Producer String IO ()
<a name="line-940"></a>&gt; input = P.stdinLn &gt;-&gt; P.takeWhile (/= "quit")
<a name="line-941"></a>&gt; 
<a name="line-942"></a>&gt; name :: ListT IO String
<a name="line-943"></a>&gt; name = do
<a name="line-944"></a>&gt;     firstName &lt;- Select input
<a name="line-945"></a>&gt;     lastName  &lt;- Select input
<a name="line-946"></a>&gt;     return (firstName ++ " " ++ lastName)
<a name="line-947"></a>
<a name="line-948"></a>    Here we're binding standard input non-deterministically (twice) as if it
<a name="line-949"></a>    were an effectful list:
<a name="line-950"></a>
<a name="line-951"></a>&gt;&gt;&gt; runEffect $ every name &gt;-&gt; P.stdoutLn
<a name="line-952"></a>Daniel&lt;Enter&gt;
<a name="line-953"></a>Fischer&lt;Enter&gt;
<a name="line-954"></a>Daniel Fischer
<a name="line-955"></a>Wagner&lt;Enter&gt;
<a name="line-956"></a>Daniel Wagner
<a name="line-957"></a>quit&lt;Enter&gt;
<a name="line-958"></a>Donald&lt;Enter&gt;
<a name="line-959"></a>Stewart&lt;Enter&gt;
<a name="line-960"></a>Donald Stewart
<a name="line-961"></a>Duck&lt;Enter&gt;
<a name="line-962"></a>Donald Duck
<a name="line-963"></a>quit&lt;Enter&gt;
<a name="line-964"></a>quit&lt;Enter&gt;
<a name="line-965"></a>&gt;&gt;&gt;
<a name="line-966"></a>
<a name="line-967"></a>    Notice how this streams out values immediately as they are generated, rather
<a name="line-968"></a>    than building up a large intermediate result and then printing all the
<a name="line-969"></a>    values in one batch at the end.
<a name="line-970"></a>
<a name="line-971"></a>    `ListT` computations can be combined in more ways than `Pipe`s, so try to
<a name="line-972"></a>    program in `ListT` as much as possible and defer converting it to a `Pipe`
<a name="line-973"></a>    as late as possible using `P.loop`.
<a name="line-974"></a>
<a name="line-975"></a>    You can combine `ListT` computations even if their inputs and outputs are
<a name="line-976"></a>    completely different:
<a name="line-977"></a>
<a name="line-978"></a>&gt; data In
<a name="line-979"></a>&gt;     = InA A
<a name="line-980"></a>&gt;     | InB B
<a name="line-981"></a>&gt;     | InC C
<a name="line-982"></a>&gt;
<a name="line-983"></a>&gt; data Out
<a name="line-984"></a>&gt;     = OutE E
<a name="line-985"></a>&gt;     | OutF F
<a name="line-986"></a>&gt;     | OutG G
<a name="line-987"></a>&gt;
<a name="line-988"></a>&gt; -- Independent computations
<a name="line-989"></a>&gt;
<a name="line-990"></a>&gt; example1 :: A -&gt; ListT IO D
<a name="line-991"></a>&gt; example2 :: B -&gt; ListT IO E
<a name="line-992"></a>&gt; example3 :: C -&gt; ListT IO F
<a name="line-993"></a>&gt;
<a name="line-994"></a>&gt; -- Combined computation
<a name="line-995"></a>&gt;
<a name="line-996"></a>&gt; total :: In -&gt; ListT IO Out
<a name="line-997"></a>&gt; total input = case input of
<a name="line-998"></a>&gt;     InA a -&gt; fmap OutD (example1 a)
<a name="line-999"></a>&gt;     InB b -&gt; fmap OutE (example2 b)
<a name="line-1000"></a>&gt;     InC c -&gt; fmap OutF (example3 c)
<a name="line-1001"></a>
<a name="line-1002"></a>    Sometimes you have multiple computations that handle different inputs but
<a name="line-1003"></a>    the same output, in which case you don't need to unify their outputs:
<a name="line-1004"></a>
<a name="line-1005"></a>&gt; -- Overlapping outputs
<a name="line-1006"></a>&gt;
<a name="line-1007"></a>&gt; example1 :: A -&gt; ListT IO Out
<a name="line-1008"></a>&gt; example2 :: B -&gt; ListT IO Out
<a name="line-1009"></a>&gt; example3 :: C -&gt; ListT IO Out
<a name="line-1010"></a>&gt;
<a name="line-1011"></a>&gt; -- Combined computation
<a name="line-1012"></a>&gt;
<a name="line-1013"></a>&gt; total :: In -&gt; ListT IO Out
<a name="line-1014"></a>&gt; total input = case input of
<a name="line-1015"></a>&gt;     InA a -&gt; example1 a
<a name="line-1016"></a>&gt;     InB b -&gt; example2 b
<a name="line-1017"></a>&gt;     InC c -&gt; example3 c
<a name="line-1018"></a>
<a name="line-1019"></a>    Other times you have multiple computations that handle the same input but
<a name="line-1020"></a>    produce different outputs.  You can unify their outputs using the `Monoid`
<a name="line-1021"></a>    and `Functor` instances for `ListT`:
<a name="line-1022"></a>
<a name="line-1023"></a>&gt; -- Overlapping inputs
<a name="line-1024"></a>&gt;
<a name="line-1025"></a>&gt; example1 :: In -&gt; ListT IO A
<a name="line-1026"></a>&gt; example2 :: In -&gt; ListT IO B
<a name="line-1027"></a>&gt; example3 :: In -&gt; ListT IO C
<a name="line-1028"></a>&gt;
<a name="line-1029"></a>&gt; -- Combined computation
<a name="line-1030"></a>&gt;
<a name="line-1031"></a>&gt; total :: In -&gt; ListT IO Out
<a name="line-1032"></a>&gt; total input =
<a name="line-1033"></a>&gt;        fmap OutA (example1 input)
<a name="line-1034"></a>&gt;     &lt;&gt; fmap OutB (example2 input)
<a name="line-1035"></a>&gt;     &lt;&gt; fmap OutC (example3 input)
<a name="line-1036"></a>
<a name="line-1037"></a>    You can also chain `ListT` computations, feeding the output of the first
<a name="line-1038"></a>    computation as the input to the next computation:
<a name="line-1039"></a>
<a name="line-1040"></a>&gt; -- End-to-end
<a name="line-1041"></a>&gt;
<a name="line-1042"></a>&gt; aToB :: A -&gt; ListT IO B
<a name="line-1043"></a>&gt; bToC :: B -&gt; ListT IO C
<a name="line-1044"></a>&gt;
<a name="line-1045"></a>&gt; -- Combined computation
<a name="line-1046"></a>&gt;
<a name="line-1047"></a>&gt; aToC :: A -&gt; LIstT IO C
<a name="line-1048"></a>&gt; aToC = aToB &gt;=&gt; bToC
<a name="line-1049"></a>
<a name="line-1050"></a>    ... or you can just use @do@ notation if you prefer.
<a name="line-1051"></a>
<a name="line-1052"></a>    However, the `Pipe` type is more general than `ListT` and can represent
<a name="line-1053"></a>    things like termination.  Therefore you should consider mixing `Pipe`s with
<a name="line-1054"></a>    `ListT` when you need to take advantage of these extra features:
<a name="line-1055"></a>
<a name="line-1056"></a>&gt; -- Mix ListT with Pipes
<a name="line-1057"></a>&gt;
<a name="line-1058"></a>&gt; example :: In -&gt; ListT IO Out
<a name="line-1059"></a>&gt;
<a name="line-1060"></a>&gt; pipe :: Pipe In Out IO ()
<a name="line-1061"></a>&gt; pipe = Pipes.takeWhile (not . isC) &gt;-&gt; loop example
<a name="line-1062"></a>&gt;   where
<a name="line-1063"></a>&gt;     isC (InC _) = True
<a name="line-1064"></a>&gt;     isC  _      = False
<a name="line-1065"></a>
<a name="line-1066"></a>    So promote your `ListT` logic to a `Pipe` when you need to take advantage of
<a name="line-1067"></a>    these `Pipe`-specific features.
<a name="line-1068"></a>-}</span>
<a name="line-1069"></a>
<a name="line-1070"></a><span class='hs-comment'>{- $tricks
<a name="line-1071"></a>    @pipes@ is more powerful than meets the eye so this section presents some
<a name="line-1072"></a>    non-obvious tricks you may find useful.
<a name="line-1073"></a>
<a name="line-1074"></a>    Many pipe combinators will work on unusual pipe types and the next few
<a name="line-1075"></a>    examples will use the 'cat' pipe to demonstrate this.
<a name="line-1076"></a>
<a name="line-1077"></a>    For example, you can loop over the output of a 'Pipe' using 'for', which is
<a name="line-1078"></a>    how 'P.map' is defined:
<a name="line-1079"></a>
<a name="line-1080"></a>&gt; map :: Monad m =&gt; (a -&gt; b) -&gt; Pipe a b m r
<a name="line-1081"></a>&gt; map f = for cat $ \x -&gt; yield (f x)
<a name="line-1082"></a>&gt;
<a name="line-1083"></a>&gt; -- Read this as: For all values flowing downstream, apply 'f'
<a name="line-1084"></a>
<a name="line-1085"></a>    This is equivalent to:
<a name="line-1086"></a>
<a name="line-1087"></a>&gt; map f = forever $ do
<a name="line-1088"></a>&gt;     x &lt;- await
<a name="line-1089"></a>&gt;     yield (f x)
<a name="line-1090"></a>
<a name="line-1091"></a>    You can also feed a 'Pipe' input using ('&gt;~').  This means we could have
<a name="line-1092"></a>    instead defined the @yes@ pipe like this:
<a name="line-1093"></a>
<a name="line-1094"></a>&gt; yes :: Monad m =&gt; Producer String m r
<a name="line-1095"></a>&gt; yes = return "y" &gt;~ cat
<a name="line-1096"></a>&gt;
<a name="line-1097"></a>&gt; -- Read this as: Keep feeding "y" downstream
<a name="line-1098"></a>
<a name="line-1099"></a>    This is equivalent to:
<a name="line-1100"></a>
<a name="line-1101"></a>&gt; yes = forever $ yield "y"
<a name="line-1102"></a>
<a name="line-1103"></a>    You can also sequence two 'Pipe's together.  This is how 'P.drop' is
<a name="line-1104"></a>    defined:
<a name="line-1105"></a>
<a name="line-1106"></a>&gt; drop :: Monad m =&gt; Int -&gt; Pipe a a m r
<a name="line-1107"></a>&gt; drop n = do
<a name="line-1108"></a>&gt;     replicateM_ n await
<a name="line-1109"></a>&gt;     cat
<a name="line-1110"></a>
<a name="line-1111"></a>    This is equivalent to:
<a name="line-1112"></a>
<a name="line-1113"></a>&gt; drop n = do
<a name="line-1114"></a>&gt;     replicateM_ n await
<a name="line-1115"></a>&gt;     forever $ do
<a name="line-1116"></a>&gt;         x &lt;- await
<a name="line-1117"></a>&gt;         yield x
<a name="line-1118"></a>
<a name="line-1119"></a>    You can even compose pipes inside of another pipe:
<a name="line-1120"></a>
<a name="line-1121"></a>&gt; customerService :: Producer String IO ()
<a name="line-1122"></a>&gt; customerService = do
<a name="line-1123"></a>&gt;     each [ "Hello, how can I help you?"        -- Begin with a script
<a name="line-1124"></a>&gt;          , "Hold for one second."
<a name="line-1125"></a>&gt;          ]
<a name="line-1126"></a>&gt;     P.stdinLn &gt;-&gt; P.takeWhile (/= "Goodbye!")  -- Now continue with a human
<a name="line-1127"></a>
<a name="line-1128"></a>    Also, you can often use 'each' in conjunction with ('~&gt;') to traverse nested
<a name="line-1129"></a>    data structures.  For example, you can print all non-'Nothing' elements
<a name="line-1130"></a>    from a doubly-nested list:
<a name="line-1131"></a>
<a name="line-1132"></a>&gt;&gt;&gt; runEffect $ (each ~&gt; each ~&gt; each ~&gt; lift . print) [[Just 1, Nothing], [Just 2, Just 3]]
<a name="line-1133"></a>1
<a name="line-1134"></a>2
<a name="line-1135"></a>3
<a name="line-1136"></a>
<a name="line-1137"></a>    Another neat thing to know is that 'every' has a more general type:
<a name="line-1138"></a>
<a name="line-1139"></a>@
<a name="line-1140"></a> 'every' :: ('Monad' m, 'Enumerable' t) =&gt; t m a -&gt; 'Producer' a m ()
<a name="line-1141"></a>@
<a name="line-1142"></a>
<a name="line-1143"></a>    'Enumerable' generalizes 'Foldable' and if you have an effectful container
<a name="line-1144"></a>    of your own that you want others to traverse using @pipes@, just have your
<a name="line-1145"></a>    container implement the 'toListT' method of the 'Enumerable' class:
<a name="line-1146"></a>
<a name="line-1147"></a>&gt; class Enumerable t where
<a name="line-1148"></a>&gt;     toListT :: Monad m =&gt; t m a -&gt; ListT m a
<a name="line-1149"></a>
<a name="line-1150"></a>    You can even use 'Enumerable' to traverse effectful types that are not even
<a name="line-1151"></a>    proper containers, like 'Control.Monad.Trans.Maybe.MaybeT':
<a name="line-1152"></a>
<a name="line-1153"></a>&gt; input :: MaybeT IO String
<a name="line-1154"></a>&gt; input = do
<a name="line-1155"></a>&gt;     str &lt;- lift getLine
<a name="line-1156"></a>&gt;     guard (str /= "Fail")
<a name="line-1157"></a>&gt;     return str
<a name="line-1158"></a>
<a name="line-1159"></a>&gt;&gt;&gt; runEffect $ every input &gt;-&gt; P.stdoutLn
<a name="line-1160"></a>Test&lt;Enter&gt;
<a name="line-1161"></a>Test
<a name="line-1162"></a>&gt;&gt;&gt; runEffect $ every input &gt;-&gt; P.stdoutLn
<a name="line-1163"></a>Fail&lt;Enter&gt;
<a name="line-1164"></a>&gt;&gt;&gt;
<a name="line-1165"></a>
<a name="line-1166"></a>-}</span>
<a name="line-1167"></a>
<a name="line-1168"></a><span class='hs-comment'>{- $conclusion
<a name="line-1169"></a>    This tutorial covers the concepts of connecting, building, and reading
<a name="line-1170"></a>    @pipes@ code.  However, this library is only the core component in an
<a name="line-1171"></a>    ecosystem of streaming components.  Derived libraries that build immediately
<a name="line-1172"></a>    upon @pipes@ include:
<a name="line-1173"></a>
<a name="line-1174"></a>    * @pipes-concurrency@: Concurrent reactive programming and message passing
<a name="line-1175"></a>
<a name="line-1176"></a>    * @pipes-parse@: Minimal utilities for stream parsing
<a name="line-1177"></a>
<a name="line-1178"></a>    * @pipes-safe@: Resource management and exception safety for @pipes@
<a name="line-1179"></a>
<a name="line-1180"></a>    * @pipes-group@: Grouping streams in constant space
<a name="line-1181"></a>
<a name="line-1182"></a>    These libraries provide functionality specialized to common streaming
<a name="line-1183"></a>    domains.  Additionally, there are several libraries on Hackage that provide
<a name="line-1184"></a>    even higher-level functionality, which you can find by searching under the
<a name="line-1185"></a>    \"Pipes\" category or by looking for packages with a @pipes-@ prefix in
<a name="line-1186"></a>    their name.  Current examples include:
<a name="line-1187"></a>
<a name="line-1188"></a>    * @pipes-extras@: Miscellaneous utilities
<a name="line-1189"></a>
<a name="line-1190"></a>    * @pipes-network@/@pipes-network-tls@: Networking
<a name="line-1191"></a>
<a name="line-1192"></a>    * @pipes-zlib@: Compression and decompression
<a name="line-1193"></a>
<a name="line-1194"></a>    * @pipes-binary@: Binary serialization
<a name="line-1195"></a>
<a name="line-1196"></a>    * @pipes-attoparsec@: High-performance parsing
<a name="line-1197"></a>
<a name="line-1198"></a>    * @pipes-aeson@: JSON serialization and deserialization
<a name="line-1199"></a>
<a name="line-1200"></a>    Even these derived packages still do not explore the full potential of
<a name="line-1201"></a>    @pipes@ functionality, which actually permits bidirectional communication.
<a name="line-1202"></a>    Advanced @pipes@ users can explore this library in greater detail by
<a name="line-1203"></a>    studying the documentation in the "Pipes.Core" module to learn about the
<a name="line-1204"></a>    symmetry of the underlying 'Proxy' type and operators.
<a name="line-1205"></a>
<a name="line-1206"></a>    To learn more about @pipes@, ask questions, or follow @pipes@ development,
<a name="line-1207"></a>    you can subscribe to the @haskell-pipes@ mailing list at:
<a name="line-1208"></a>
<a name="line-1209"></a>    &lt;https://groups.google.com/forum/#!forum/haskell-pipes&gt;
<a name="line-1210"></a>
<a name="line-1211"></a>    ... or you can mail the list directly at:
<a name="line-1212"></a>
<a name="line-1213"></a>    &lt;mailto:haskell-pipes@googlegroups.com&gt;
<a name="line-1214"></a>
<a name="line-1215"></a>    Additionally, for questions regarding types or type errors, you might find
<a name="line-1216"></a>    the following appendix on types very useful.
<a name="line-1217"></a>-}</span>
<a name="line-1218"></a>
<a name="line-1219"></a><span class='hs-comment'>{- $types
<a name="line-1220"></a>    @pipes@ uses parametric polymorphism (i.e. generics) to overload all
<a name="line-1221"></a>    operations.  You've probably noticed this overloading already:
<a name="line-1222"></a>
<a name="line-1223"></a>    * 'yield' works within both 'Producer's and 'Pipe's
<a name="line-1224"></a>
<a name="line-1225"></a>    * 'await' works within both 'Consumer's and 'Pipe's
<a name="line-1226"></a>
<a name="line-1227"></a>    * ('&gt;-&gt;') connects 'Producer's, 'Consumer's, and 'Pipe's in varying ways
<a name="line-1228"></a>
<a name="line-1229"></a>    This overloading is great when it works, but when connections fail they
<a name="line-1230"></a>    produce type errors that appear intimidating at first.  This section
<a name="line-1231"></a>    explains the underlying types so that you can work through type errors
<a name="line-1232"></a>    intelligently.
<a name="line-1233"></a>
<a name="line-1234"></a>    'Producer's, 'Consumer's, 'Pipe's, and 'Effect's are all special cases of a
<a name="line-1235"></a>    single underlying type: a 'Proxy'.  This overarching type permits fully
<a name="line-1236"></a>    bidirectional communication on both an upstream and downstream interface.
<a name="line-1237"></a>    You can think of it as having the following shape:
<a name="line-1238"></a>
<a name="line-1239"></a>&gt; Proxy a' a b' b m r
<a name="line-1240"></a>&gt;
<a name="line-1241"></a>&gt; Upstream | Downstream
<a name="line-1242"></a>&gt;     +---------+
<a name="line-1243"></a>&gt;     |         |
<a name="line-1244"></a>&gt; a' &lt;==       &lt;== b'  -- Information flowing upstream
<a name="line-1245"></a>&gt;     |         |
<a name="line-1246"></a>&gt; a  ==&gt;       ==&gt; b   -- Information flowing downstream
<a name="line-1247"></a>&gt;     |    |    |
<a name="line-1248"></a>&gt;     +----|----+
<a name="line-1249"></a>&gt;          v
<a name="line-1250"></a>&gt;          r
<a name="line-1251"></a>
<a name="line-1252"></a>    The four core types do not use the upstream flow of information.  This means
<a name="line-1253"></a>    that the @a'@ and @b'@ in the above diagram go unused unless you use the
<a name="line-1254"></a>    more advanced features provided in "Pipes.Core".
<a name="line-1255"></a>
<a name="line-1256"></a>    @pipes@ uses type synonyms to hide unused inputs or outputs and clean up
<a name="line-1257"></a>    type signatures.  These type synonyms come in two flavors:
<a name="line-1258"></a>
<a name="line-1259"></a>    * Concrete type synonyms that explicitly close unused inputs and outputs of
<a name="line-1260"></a>      the 'Proxy' type
<a name="line-1261"></a>
<a name="line-1262"></a>    * Polymorphic type synonyms that don't explicitly close unused inputs or
<a name="line-1263"></a>      outputs
<a name="line-1264"></a>
<a name="line-1265"></a>    The concrete type synonyms use @()@ to close unused inputs and 'X' (the
<a name="line-1266"></a>    uninhabited type) to close unused outputs:
<a name="line-1267"></a>
<a name="line-1268"></a>    * 'Effect': explicitly closes both ends, forbidding 'await's and 'yield's
<a name="line-1269"></a>
<a name="line-1270"></a>&gt; type Effect = Proxy X () () X
<a name="line-1271"></a>&gt;
<a name="line-1272"></a>&gt;  Upstream | Downstream
<a name="line-1273"></a>&gt;     +---------+
<a name="line-1274"></a>&gt;     |         |
<a name="line-1275"></a>&gt; X  &lt;==       &lt;== ()
<a name="line-1276"></a>&gt;     |         |
<a name="line-1277"></a>&gt; () ==&gt;       ==&gt; X
<a name="line-1278"></a>&gt;     |    |    |
<a name="line-1279"></a>&gt;     +----|----+
<a name="line-1280"></a>&gt;          v
<a name="line-1281"></a>&gt;          r
<a name="line-1282"></a>
<a name="line-1283"></a>    * 'Producer': explicitly closes the upstream end, forbidding 'await's
<a name="line-1284"></a>
<a name="line-1285"></a>&gt; type Producer b = Proxy X () () b
<a name="line-1286"></a>&gt;
<a name="line-1287"></a>&gt; Upstream | Downstream
<a name="line-1288"></a>&gt;     +---------+
<a name="line-1289"></a>&gt;     |         |
<a name="line-1290"></a>&gt; X  &lt;==       &lt;== ()
<a name="line-1291"></a>&gt;     |         |
<a name="line-1292"></a>&gt; () ==&gt;       ==&gt; b
<a name="line-1293"></a>&gt;     |    |    |
<a name="line-1294"></a>&gt;     +----|----+
<a name="line-1295"></a>&gt;          v
<a name="line-1296"></a>&gt;          r
<a name="line-1297"></a>
<a name="line-1298"></a>    * 'Consumer': explicitly closes the downstream end, forbidding 'yield's
<a name="line-1299"></a>
<a name="line-1300"></a>&gt; type Consumer a = Proxy () a () X
<a name="line-1301"></a>&gt;
<a name="line-1302"></a>&gt; Upstream | Downstream
<a name="line-1303"></a>&gt;     +---------+
<a name="line-1304"></a>&gt;     |         |
<a name="line-1305"></a>&gt; () &lt;==       &lt;== ()
<a name="line-1306"></a>&gt;     |         |
<a name="line-1307"></a>&gt; a  ==&gt;       ==&gt; X
<a name="line-1308"></a>&gt;     |    |    |
<a name="line-1309"></a>&gt;     +----|----+
<a name="line-1310"></a>&gt;          v
<a name="line-1311"></a>&gt;          r
<a name="line-1312"></a>
<a name="line-1313"></a>    * 'Pipe': marks both ends open, allowing both 'await's and 'yield's
<a name="line-1314"></a>
<a name="line-1315"></a>&gt; type Pipe a b = Proxy () a () b
<a name="line-1316"></a>&gt;
<a name="line-1317"></a>&gt; Upstream | Downstream
<a name="line-1318"></a>&gt;     +---------+
<a name="line-1319"></a>&gt;     |         |
<a name="line-1320"></a>&gt; () &lt;==       &lt;== ()
<a name="line-1321"></a>&gt;     |         |
<a name="line-1322"></a>&gt; a  ==&gt;       ==&gt; b
<a name="line-1323"></a>&gt;     |    |    |
<a name="line-1324"></a>&gt;     +----|----+
<a name="line-1325"></a>&gt;          v
<a name="line-1326"></a>&gt;          r
<a name="line-1327"></a>
<a name="line-1328"></a>    When you compose 'Proxy's using ('&gt;-&gt;') all you are doing is placing them
<a name="line-1329"></a>    side by side and fusing them laterally.  For example, when you compose a
<a name="line-1330"></a>    'Producer', 'Pipe', and a 'Consumer', you can think of information flowing
<a name="line-1331"></a>    like this:
<a name="line-1332"></a>
<a name="line-1333"></a>&gt;        Producer                Pipe                 Consumer
<a name="line-1334"></a>&gt;     +-----------+          +----------+          +------------+
<a name="line-1335"></a>&gt;     |           |          |          |          |            |
<a name="line-1336"></a>&gt; X  &lt;==         &lt;==   ()   &lt;==        &lt;==   ()   &lt;==          &lt;== ()
<a name="line-1337"></a>&gt;     |  stdinLn  |          |  take 3  |          |  stdoutLn  |
<a name="line-1338"></a>&gt; () ==&gt;         ==&gt; String ==&gt;        ==&gt; String ==&gt;          ==&gt; X
<a name="line-1339"></a>&gt;     |     |     |          |    |     |          |      |     |
<a name="line-1340"></a>&gt;     +-----|-----+          +----|-----+          +------|-----+
<a name="line-1341"></a>&gt;           v                     v                       v
<a name="line-1342"></a>&gt;           ()                    ()                      ()
<a name="line-1343"></a>
<a name="line-1344"></a>     Composition fuses away the intermediate interfaces, leaving behind an
<a name="line-1345"></a>     'Effect':
<a name="line-1346"></a>
<a name="line-1347"></a>&gt;                    Effect
<a name="line-1348"></a>&gt;     +-----------------------------------+
<a name="line-1349"></a>&gt;     |                                   |
<a name="line-1350"></a>&gt; X  &lt;==                                 &lt;== ()
<a name="line-1351"></a>&gt;     |  stdinLn &gt;-&gt; take 3 &gt;-&gt; stdoutLn  |
<a name="line-1352"></a>&gt; () ==&gt;                                 ==&gt; X
<a name="line-1353"></a>&gt;     |                                   |
<a name="line-1354"></a>&gt;     +----------------|------------------+
<a name="line-1355"></a>&gt;                      v
<a name="line-1356"></a>&gt;                      ()
<a name="line-1357"></a>
<a name="line-1358"></a>    @pipes@ also provides polymorphic type synonyms with apostrophes at the end
<a name="line-1359"></a>    of their names.  These use universal quantification to leave open any unused
<a name="line-1360"></a>    input or output ends (which I mark using @*@):
<a name="line-1361"></a>
<a name="line-1362"></a>    * 'Producer'': marks the upstream end unused but still open
<a name="line-1363"></a>
<a name="line-1364"></a>&gt; type Producer' b m r = forall x' x . Proxy x' x () b m r
<a name="line-1365"></a>&gt;
<a name="line-1366"></a>&gt; Upstream | Downstream
<a name="line-1367"></a>&gt;     +---------+
<a name="line-1368"></a>&gt;     |         |
<a name="line-1369"></a>&gt;  * &lt;==       &lt;== ()
<a name="line-1370"></a>&gt;     |         |
<a name="line-1371"></a>&gt;  * ==&gt;       ==&gt; b
<a name="line-1372"></a>&gt;     |    |    |
<a name="line-1373"></a>&gt;     +----|----+
<a name="line-1374"></a>&gt;          v
<a name="line-1375"></a>&gt;          r
<a name="line-1376"></a>
<a name="line-1377"></a>    * 'Consumer'': marks the downstream end unused but still open
<a name="line-1378"></a>
<a name="line-1379"></a>&gt; type Consumer' a m r = forall y' y . Proxy () a y' y m r
<a name="line-1380"></a>&gt;
<a name="line-1381"></a>&gt; Upstream | Downstream
<a name="line-1382"></a>&gt;     +---------+
<a name="line-1383"></a>&gt;     |         |
<a name="line-1384"></a>&gt; () &lt;==       &lt;== * 
<a name="line-1385"></a>&gt;     |         |
<a name="line-1386"></a>&gt; a  ==&gt;       ==&gt; *
<a name="line-1387"></a>&gt;     |    |    |
<a name="line-1388"></a>&gt;     +----|----+
<a name="line-1389"></a>&gt;          v
<a name="line-1390"></a>&gt;          r
<a name="line-1391"></a>
<a name="line-1392"></a>    * 'Effect'': marks both ends unused but still open
<a name="line-1393"></a>
<a name="line-1394"></a>&gt; type Effect' m r = forall x' x y' y . Proxy x' x y' y m r
<a name="line-1395"></a>&gt;
<a name="line-1396"></a>&gt; Upstream | Downstream
<a name="line-1397"></a>&gt;     +---------+
<a name="line-1398"></a>&gt;     |         |
<a name="line-1399"></a>&gt;  * &lt;==       &lt;== * 
<a name="line-1400"></a>&gt;     |         |
<a name="line-1401"></a>&gt;  * ==&gt;       ==&gt; *
<a name="line-1402"></a>&gt;     |    |    |
<a name="line-1403"></a>&gt;     +----|----+
<a name="line-1404"></a>&gt;          v
<a name="line-1405"></a>&gt;          r
<a name="line-1406"></a>
<a name="line-1407"></a>    Note that there is no polymorphic generalization of a 'Pipe'.
<a name="line-1408"></a>
<a name="line-1409"></a>    Like before, if you compose a 'Producer'', a 'Pipe', and a 'Consumer'':
<a name="line-1410"></a>
<a name="line-1411"></a>&gt;        Producer'               Pipe                 Consumer'
<a name="line-1412"></a>&gt;     +-----------+          +----------+          +------------+
<a name="line-1413"></a>&gt;     |           |          |          |          |            |
<a name="line-1414"></a>&gt;  * &lt;==         &lt;==   ()   &lt;==        &lt;==   ()   &lt;==          &lt;== *
<a name="line-1415"></a>&gt;     |  stdinLn  |          |  take 3  |          |  stdoutLn  |
<a name="line-1416"></a>&gt;  * ==&gt;         ==&gt; String ==&gt;        ==&gt; String ==&gt;          ==&gt; *
<a name="line-1417"></a>&gt;     |     |     |          |     |    |          |      |     |
<a name="line-1418"></a>&gt;     +-----|-----+          +-----|----+          +------|-----+
<a name="line-1419"></a>&gt;           v                      v                      v
<a name="line-1420"></a>&gt;           ()                     ()                     ()
<a name="line-1421"></a>
<a name="line-1422"></a>    ... they fuse into an 'Effect'':
<a name="line-1423"></a>
<a name="line-1424"></a>&gt;                    Effect'
<a name="line-1425"></a>&gt;     +-----------------------------------+
<a name="line-1426"></a>&gt;     |                                   |
<a name="line-1427"></a>&gt;  * &lt;==                                 &lt;== *
<a name="line-1428"></a>&gt;     |  stdinLn &gt;-&gt; take 3 &gt;-&gt; stdoutLn  |
<a name="line-1429"></a>&gt;  * ==&gt;                                 ==&gt; *
<a name="line-1430"></a>&gt;     |                                   |
<a name="line-1431"></a>&gt;     +----------------|------------------+
<a name="line-1432"></a>&gt;                      v
<a name="line-1433"></a>&gt;                      ()
<a name="line-1434"></a>
<a name="line-1435"></a>    Polymorphic type synonyms come in handy when you want to keep the type as
<a name="line-1436"></a>    general as possible.  For example, the type signature for 'yield' uses
<a name="line-1437"></a>    'Producer'' to keep the type signature simple while still leaving the
<a name="line-1438"></a>    upstream input end open:
<a name="line-1439"></a>
<a name="line-1440"></a>@
<a name="line-1441"></a> 'yield' :: 'Monad' m =&gt; a -&gt; 'Producer'' a m ()
<a name="line-1442"></a>@
<a name="line-1443"></a>
<a name="line-1444"></a>    This type signature lets us use 'yield' within a 'Pipe', too, because the
<a name="line-1445"></a>    'Pipe' type synonym is a special case of the polymorphic 'Producer'' type 
<a name="line-1446"></a>    synonym:
<a name="line-1447"></a>
<a name="line-1448"></a>@
<a name="line-1449"></a> type 'Producer'' b m r = forall x' x . 'Proxy' x' x () b m r
<a name="line-1450"></a> type 'Pipe'    a b m r =               'Proxy' () a () b m r
<a name="line-1451"></a>@
<a name="line-1452"></a>
<a name="line-1453"></a>    The same is true for 'await', which uses the polymorphic 'Consumer'' type
<a name="line-1454"></a>    synonym:
<a name="line-1455"></a>
<a name="line-1456"></a>@
<a name="line-1457"></a> 'await' :: 'Monad' m =&gt; 'Consumer'' a m a
<a name="line-1458"></a>@
<a name="line-1459"></a>
<a name="line-1460"></a>    We can use 'await' within a 'Pipe' because a 'Pipe' is a special case of the
<a name="line-1461"></a>    polymorphic 'Consumer'' type synonym:
<a name="line-1462"></a>
<a name="line-1463"></a>@
<a name="line-1464"></a> type 'Consumer'' a   m r = forall y' y . 'Proxy' () a y' y m r
<a name="line-1465"></a> type 'Pipe'      a b m r =               'Proxy' () a () b m r
<a name="line-1466"></a>@
<a name="line-1467"></a>
<a name="line-1468"></a>    However, polymorphic type synonyms cause problems in many other cases:
<a name="line-1469"></a>
<a name="line-1470"></a>    * They usually give the wrong behavior when used as the argument of a
<a name="line-1471"></a>      function (known as the \"negative\" or \"contravariant\" position) like
<a name="line-1472"></a>      this:
<a name="line-1473"></a>
<a name="line-1474"></a>&gt; f :: Producer' a m r -&gt; ...  -- Wrong
<a name="line-1475"></a>&gt;
<a name="line-1476"></a>&gt; f :: Producer  a m r -&gt; ...  -- Right
<a name="line-1477"></a>
<a name="line-1478"></a>      The former function only accepts polymorphic 'Producer's as arguments.
<a name="line-1479"></a>      The latter function accepts both polymorphic and concrete 'Producer's,
<a name="line-1480"></a>      which is probably what you want.
<a name="line-1481"></a>
<a name="line-1482"></a>    * Even when you desire a polymorphic argument, this induces a higher-ranked
<a name="line-1483"></a>      type, because it translates to a @forall@ which you cannot factor out to
<a name="line-1484"></a>      the top-level to simplify the type signature:
<a name="line-1485"></a>
<a name="line-1486"></a>&gt; f :: (forall x' x y' . Proxy x' x y' m r) -&gt; ...
<a name="line-1487"></a>
<a name="line-1488"></a>      These kinds of type signatures require the @RankNTypes@ extension.
<a name="line-1489"></a>
<a name="line-1490"></a>    * Even when you have polymorphic type synonyms as the result of a function
<a name="line-1491"></a>      (i.e.  the \"positive\" or \"covariant\" position), recent versions of
<a name="line-1492"></a>      @ghc@ such still require the @RankNTypes@ extension.  For example, the
<a name="line-1493"></a>      'Pipes.Prelude.fromHandle' function from "Pipes.Prelude" requires
<a name="line-1494"></a>      @RankNTypes@ to compile correctly on @ghc-7.6.3@:
<a name="line-1495"></a>
<a name="line-1496"></a>&gt; fromHandle :: MonadIO m =&gt; Handle -&gt; Producer' String m ()
<a name="line-1497"></a>
<a name="line-1498"></a>    * You can't use polymorphic type synonyms inside other type constructors
<a name="line-1499"></a>      without the @ImpredicativeTypes@ extension:
<a name="line-1500"></a>
<a name="line-1501"></a>&gt; io :: IO (Producer' a m r)  -- Type error without ImpredicativeTypes
<a name="line-1502"></a>
<a name="line-1503"></a>    * You can't partially apply polymorphic type synonyms:
<a name="line-1504"></a>
<a name="line-1505"></a>&gt; stack :: MaybeT (Producer' a m) r  -- Type error
<a name="line-1506"></a>
<a name="line-1507"></a>    In these scenarios you should fall back on the concrete type synonyms, which
<a name="line-1508"></a>    are better behaved.  If concrete type synonyms are unsatisfactory, then ask
<a name="line-1509"></a>    @ghc@ to infer the most general type signature and use that.
<a name="line-1510"></a>
<a name="line-1511"></a>    For the purposes of debugging type errors you can just remember that:
<a name="line-1512"></a>
<a name="line-1513"></a>&gt;  Input --+    +-- Output
<a name="line-1514"></a>&gt;          |    |
<a name="line-1515"></a>&gt;          v    v
<a name="line-1516"></a>&gt; Proxy a' a b' b m r
<a name="line-1517"></a>&gt;       ^    ^
<a name="line-1518"></a>&gt;       |    |
<a name="line-1519"></a>&gt;       +----+-- Ignore these
<a name="line-1520"></a>
<a name="line-1521"></a>    For example, let's say that you try to run the 'P.stdinLn' 'Producer'.  This
<a name="line-1522"></a>    produces the following type error:
<a name="line-1523"></a>
<a name="line-1524"></a>&gt;&gt;&gt; runEffect P.stdinLn
<a name="line-1525"></a>&lt;interactive&gt;:4:5:
<a name="line-1526"></a>    Couldn't match expected type `X' with actual type `String'
<a name="line-1527"></a>    Expected type: Effect m0 r0
<a name="line-1528"></a>      Actual type: Proxy X () () String IO ()
<a name="line-1529"></a>    In the first argument of `runEffect', namely `P.stdinLn'
<a name="line-1530"></a>    In the expression: runEffect P.stdinLn
<a name="line-1531"></a>
<a name="line-1532"></a>    'runEffect' expects an 'Effect', which is equivalent to the following type:
<a name="line-1533"></a>
<a name="line-1534"></a>&gt; Effect          IO () = Proxy X () () X      IO ()
<a name="line-1535"></a>
<a name="line-1536"></a>    ... but 'P.stdinLn' type-checks as a 'Producer', which has the following
<a name="line-1537"></a>    type:
<a name="line-1538"></a>
<a name="line-1539"></a>&gt; Producer String IO () = Proxy X () () String IO ()
<a name="line-1540"></a>
<a name="line-1541"></a>    The fourth type variable (the output) does not match.  For an 'Effect' this
<a name="line-1542"></a>    type variable should be closed (i.e. 'X'), but 'P.stdinLn' has a 'String'
<a name="line-1543"></a>    output, thus the type error:
<a name="line-1544"></a>
<a name="line-1545"></a>&gt;    Couldn't match expected type `X' with actual type `String'
<a name="line-1546"></a>
<a name="line-1547"></a>    Any time you get type errors like these you can work through them by
<a name="line-1548"></a>    expanding out the type synonyms and seeing which type variables do not
<a name="line-1549"></a>    match.
<a name="line-1550"></a>
<a name="line-1551"></a>    You may also consult this table of type synonyms to more easily compare
<a name="line-1552"></a>    them:
<a name="line-1553"></a>
<a name="line-1554"></a>&gt; type Effect             = Proxy X  () () X
<a name="line-1555"></a>&gt; type Producer         b = Proxy X  () () b
<a name="line-1556"></a>&gt; type Consumer    a      = Proxy () a  () X
<a name="line-1557"></a>&gt; type Pipe        a    b = Proxy () a  () b
<a name="line-1558"></a>&gt;
<a name="line-1559"></a>&gt; type Server        b' b = Proxy X  () b' b 
<a name="line-1560"></a>&gt; type Client   a' a      = Proxy a' a  () X
<a name="line-1561"></a>&gt;
<a name="line-1562"></a>&gt; type Effect'            m r = forall x' x y' y . Proxy x' x y' y m r
<a name="line-1563"></a>&gt; type Producer'        b m r = forall x' x      . Proxy x' x () b m r
<a name="line-1564"></a>&gt; type Consumer'   a      m r = forall      y' y . Proxy () a y' y m r
<a name="line-1565"></a>&gt;
<a name="line-1566"></a>&gt; type Server'       b' b m r = forall x' x      . Proxy x' x b' b m r
<a name="line-1567"></a>&gt; type Client'  a' a      m r = forall      y' y . Proxy a' a y' y m r
<a name="line-1568"></a>
<a name="line-1569"></a>-}</span>
<a name="line-1570"></a>
<a name="line-1571"></a><span class='hs-comment'>{- $timecomplexity
<a name="line-1572"></a>    There are three functions that give quadratic time complexity when used in
<a name="line-1573"></a>    within @pipes@:
<a name="line-1574"></a>
<a name="line-1575"></a>    * 'sequence'
<a name="line-1576"></a>
<a name="line-1577"></a>    * 'replicateM'
<a name="line-1578"></a>
<a name="line-1579"></a>    * 'mapM'
<a name="line-1580"></a>
<a name="line-1581"></a>    For example, the time complexity of this code segment scales quadratically
<a name="line-1582"></a>    with `n`:
<a name="line-1583"></a>
<a name="line-1584"></a>&gt; import Control.Monad (replicateM)
<a name="line-1585"></a>&gt; import Pipes
<a name="line-1586"></a>&gt;
<a name="line-1587"></a>&gt; quadratic :: Int -&gt; Consumer a m [a]
<a name="line-1588"></a>&gt; quadratic n = replicateM n await
<a name="line-1589"></a>
<a name="line-1590"></a>    These three functions are generally bad practice to use, because all three
<a name="line-1591"></a>    of them correspond to \"ListT done wrong\", building a list in memory
<a name="line-1592"></a>    instead of streaming results.
<a name="line-1593"></a>
<a name="line-1594"></a>    However, sometimes situations arise where one deliberately intends to build
<a name="line-1595"></a>    a list in memory.  The solution is to use the \"codensity transformation\"
<a name="line-1596"></a>    to transform the code to run with linear time complexity.  This involves:
<a name="line-1597"></a>
<a name="line-1598"></a>    * wrapping the code in the @Codensity@ monad transformer (from
<a name="line-1599"></a>      @Control.Monad.Codensity@ module of the @kan-extensions@ package) using
<a name="line-1600"></a>      'lift'
<a name="line-1601"></a>
<a name="line-1602"></a>    * applying 'sequence' \/ 'replicateM' \/ 'mapM'
<a name="line-1603"></a>
<a name="line-1604"></a>    * unwrapping the code using @lowerCodensity@
<a name="line-1605"></a>
<a name="line-1606"></a>    To illustrate this, we'd transform the above example to:
<a name="line-1607"></a>
<a name="line-1608"></a>&gt; import Control.Monad.Codensity (lowerCodensity)
<a name="line-1609"></a>&gt; 
<a name="line-1610"></a>&gt; linear :: Monad m =&gt; Int -&gt; Consumer a m [a]
<a name="line-1611"></a>&gt; linear n = lowerCodensity $ replicateM n $ lift await
<a name="line-1612"></a>
<a name="line-1613"></a>    This will produce the exact same result, but in linear time.
<a name="line-1614"></a>-}</span>
<a name="line-1615"></a>
<a name="line-1616"></a><span class='hs-comment'>{- $copyright
<a name="line-1617"></a>    This tutorial is licensed under a
<a name="line-1618"></a>    &lt;<a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a> Creative Commons Attribution 4.0 International License&gt;
<a name="line-1619"></a>-}</span>
</pre></body>
</html>
