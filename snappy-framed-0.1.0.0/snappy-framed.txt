-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Decompression for framed Snappy streams
--   
--   Please see README.md
@package snappy-framed
@version 0.1.0.0


-- | An unframed snappy stream.
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  07 18 66 6f 6f 62 61 72  0a                       |..foobar.|
--   </pre>
--   
--   Reference:
--   <a>https://github.com/google/snappy/blob/master/format_description.txt</a>
module Codec.Compression.Snappy.Framed.NoFraming

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | A format defined in a comment on an issue in the old snappy issue
--   tracker.
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  ff 06 00 73 6e 61 70 70  79 01 0b 00 0a 17 bb 3a  |...snappy......:|
--   00000010  66 6f 6f 62 61 72 0a fe  00 00                    |foobar....|
--   </pre>
--   
--   Reference:
--   <a>http://code.google.com/p/snappy/issues/detail?id=34#c43</a> (Broken
--   link, not in the Wayback Machine. Lost to history?)
module Codec.Compression.Snappy.Framed.Comment43

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | A format developed as part of the snappy java library.
--   
--   From the docs:
--   
--   <pre>
--   The output format is the stream header "snappy\0" followed by one or
--   more compressed blocks of data, each of which is preceded by a seven
--   byte header.
--   
--   The first byte of the header is a flag indicating if the block is
--   compressed or not. A value of 0x00 means uncompressed, and 0x01 means
--   compressed.
--   
--   The second and third bytes are the size of the block in the stream as
--   a big endian number. This value is never zero as empty blocks are
--   never written. The maximum allowed length is 32k (1 &lt;&lt; 15).
--   
--   The remaining four byes are crc32c checksum of the user input data
--   masked with the following function: {@code ((crc &gt;&gt;&gt; 15) | (crc &lt;&lt;
--   17)) + 0xa282ead8 }
--   
--   An uncompressed block is simply copied from the input, thus
--   guaranteeing that the output is never larger than the input (not
--   including the header).
--   </pre>
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  73 6e 61 70 70 79 00 00  00 07 3a bb 17 0a 66 6f  |snappy....:...fo|
--   00000010  6f 62 61 72 0a                                    |obar.|
--   </pre>
--   
--   Reference: <a>https://github.com/dain/snappy</a>
module Codec.Compression.Snappy.Framed.SnappyInJava

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | A format developed as part of the snappy-java library.
--   
--   From the docs:
--   
--   <pre>
--   SnappyOutputStream and SnappyInputStream use `[magic header:16
--   bytes]([block size:int32][compressed data:byte array])*` format
--   </pre>
--   
--   The following example encoding was produced on an x86 machine, yet the
--   "block size" int32 appears to be big-endian. Therefore, I'm assuming
--   that this is an unwritten part of the spec.
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  82 53 4e 41 50 50 59 00  00 00 00 01 00 00 00 01  |.SNAPPY.........|
--   00000010  00 00 00 09 07 18 66 6f  6f 62 61 72 0a           |......foobar.|
--   </pre>
--   
--   Reference: <a>http://code.google.com/p/snappy-java/</a>
module Codec.Compression.Snappy.Framed.SnappyJava

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | A format developed as part of the snzip application.
--   
--   From the docs:
--   
--   <pre>
--   The first three bytes are magic characters 'SNZ'.
--   
--   The fourth byte is the file format version. It is 0x01.
--   
--   The fifth byte is the order of the block size. The input data is
--   divided into fixed-length blocks and each block is compressed by
--   snappy. When it is 16 (default value), the block size is 16th power of
--   2; 64 kilobytes.
--   
--   The rest is pairs of a compressed data length and a compressed data
--   block The compressed data length is encoded as
--   snappy::Varint::Encode32() does. If the length is zero, it is the end
--   of data.
--   
--   Though the rest after the end of data is ignored for now, they may be
--   continuously read as a next compressed file as gzip does.
--   
--   Note that the uncompressed length of each compressed data block must
--   be less than or equal to the block size specified by the fifth byte.
--   </pre>
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  53 4e 5a 01 10 09 07 18  66 6f 6f 62 61 72 0a 00  |SNZ.....foobar..|
--   </pre>
--   
--   Reference: <a>https://github.com/kubo/snzip</a>
module Codec.Compression.Snappy.Framed.SNZip

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | An old version of the official format.
--   
--   The name "framing1" refers to the format specified in the following
--   revision of the official snappy repo:
--   
--   <ul>
--   <li>framing format revision 2011-12-15, snappy 1.0.5, svn r55, git
--   0755c81</li>
--   </ul>
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  ff 06 00 73 4e 61 50 70  59 01 0b 00 0a 17 bb 3a  |...sNaPpY......:|
--   00000010  66 6f 6f 62 61 72 0a                              |foobar.|
--   </pre>
--   
--   Reference:
--   <a>https://github.com/google/snappy/blob/0755c81/framing_format.txt</a>
module Codec.Compression.Snappy.Framed.Framing1

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: Parser ByteString


-- | The current version of the official format.
--   
--   The name "framing2" refers to the format which was specified and then
--   (backwards-compatibly) modified in the following revisions of the
--   official snappy repo:
--   
--   <ul>
--   <li>framing format revision 2013-01-05, snappy 1.1.0, svn r71, git
--   27a0cc3</li>
--   <li>framing format revision 2013-10-25, snappy 1.1.2, svn r82, git
--   f82bff6</li>
--   </ul>
--   
--   Example encoding of the string "foobar\n":
--   
--   <pre>
--   00000000  ff 06 00 00 73 4e 61 50  70 59 01 0b 00 00 0a 17  |....sNaPpY......|
--   00000010  bb 3a 66 6f 6f 62 61 72  0a                       |.:foobar.|
--   </pre>
--   
--   Reference:
--   <a>https://github.com/google/snappy/blob/f82bff6/framing_format.txt</a>
module Codec.Compression.Snappy.Framed.Framing2

-- | Attempt to parse the header. If the header exists, it will be
--   consumed. If not, the parser will fail.
parseHeader :: Parser ()

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
--   
--   TODO (asayers): defer to snappy-framing package, which implements this
--   format.
parseBlock :: Parser ByteString


-- | This module provides facilities for decoding framed Snappy streams.
--   
--   Snappy is a block compression format, meaning that the whole
--   compressed stream must be kept in memory until it is fully decoded
--   [1]. The task of splitting data into a stream of
--   independently-decodable chunks is handled by the framing format. In
--   addition, this format often provides checksums of the uncompressed
--   data.
--   
--   Unfortunately, for a long time snappy had no official framing format,
--   and so a number of improvised formats appeared. While there is now a
--   standard format, many of the historical formats are still in common
--   use. The good news is that these formats mercifully begin with
--   distinct magic byte sequences, and so can be easily distinguished.
--   
--   The list of formats, and the names given to them, come from the snzip
--   application (https:/<i>github.com</i>kubo/snzip).
--   
--   [1]: In Snappy, the offsets used by back-references may be as large as
--   a 32-bit word. As a result, a byte in the uncompressed stream can't be
--   discarded until 4GB of uncompressed data following it has been
--   decoded. This effectively makes Snappy a block compression format.
--   
--   TODO (asayers): Tests
module Codec.Compression.Snappy.Framed

-- | Decompress a framed Snappy stream, reporting errors.
decompress :: (Monad m) => ByteString -> Producer ByteString m (Either String ())

-- | Decompress a framed Snappy stream, raising an exception on bad input.
--   TODO (asayers): better names
decompress_ :: (Monad m) => ByteString -> Producer ByteString m ()

-- | Decompress a framed Snappy stream, returning unconsumed input in the
--   case of an error. TODO (asayers): we can do better in terms of
--   streaming the input.
decompress__ :: (Monad m) => ByteString -> Producer ByteString m (Either (ParsingError, Producer ByteString m ()) ())

-- | Snappy unfortunately has a variety of historical framing formats, and
--   while the comminity has now accepted "framing2" as the default, Kafka
--   still uses the "snappy-java" framing format.
data FramingFormat
Framing2 :: FramingFormat
Framing1 :: FramingFormat
SNZip :: FramingFormat
SnappyJava :: FramingFormat
SnappyInJava :: FramingFormat
Comment43 :: FramingFormat
NoFraming :: FramingFormat

-- | Attempt to parse the headers of each format in turn. This tells us
--   which format we're using. If we don't see a header we recognise, we
--   assume that we've been given an unframed snappy stream.
parseHeader :: Parser FramingFormat

-- | Parse a single block of the compressed bytestream, returning a segment
--   of the uncompressed stream.
parseBlock :: FramingFormat -> Parser ByteString
